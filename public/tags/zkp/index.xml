<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ZKP on Giap&#39;s Blog</title>
    <link>http://localhost:40099/tags/zkp/</link>
    <description>Recent content in ZKP on Giap&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <managingEditor>michael@michaelneuper.com (Michael Neuper)</managingEditor>
    <webMaster>michael@michaelneuper.com (Michael Neuper)</webMaster>
    <lastBuildDate>Tue, 17 Sep 2024 00:00:00 +0000</lastBuildDate><atom:link href="http://localhost:40099/tags/zkp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Zero Knowledge Proof: FRI-based Polynomial Commitments and Fiat-Shamir</title>
      <link>http://localhost:40099/posts/zkp7/</link>
      <pubDate>Tue, 17 Sep 2024 00:00:00 +0000</pubDate>
      <author>michael@michaelneuper.com (Michael Neuper)</author>
      <guid>http://localhost:40099/posts/zkp7/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Zero Knowledge Proof: Polynomial Commitments based on Error-correcting Codes</title>
      <link>http://localhost:40099/posts/zkp6/</link>
      <pubDate>Sat, 17 Aug 2024 00:00:00 +0000</pubDate>
      <author>michael@michaelneuper.com (Michael Neuper)</author>
      <guid>http://localhost:40099/posts/zkp6/</guid>
      <description>&lt;p&gt;In this post, we will talk about other polynomial commitment scheme based on Error-correcting codes.&lt;/p&gt;
&lt;h2 id=&#34;resources&#34;&gt;Resources&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://crypto-notes-erhant.vercel.app/zklearning/poly-commits-on-error-correcting.html&#34;&gt;Poly-commits: Error-Correcting Codes - Cryptonotes&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://acmccs.github.io/papers/p2087-amesA.pdf&#34;&gt;Ligero paper&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://eprint.iacr.org/2022/1010&#34;&gt;Orion paper&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://eprint.iacr.org/2021/1043&#34;&gt;Brakedown paper&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;background&#34;&gt;Background&lt;/h2&gt;
&lt;h3 id=&#34;error-correcting-code&#34;&gt;Error-correcting code&lt;/h3&gt;
&lt;p&gt;An error-correcting code &lt;strong&gt;encodes&lt;/strong&gt; a &lt;strong&gt;message&lt;/strong&gt; of length $k$ into a &lt;strong&gt;codeword&lt;/strong&gt; of length $n$, where $n &amp;gt; k$. The minimum distance (which is well-known as Hamming distance) between any two codewords is shown as $\Delta$. These parameters are important, and we may refer to an error-correcting code as $[n, k, \Delta]$ code.&lt;/p&gt;
&lt;p&gt;For example, let&amp;rsquo;s take a look at repetition code: $[6, 2, \Delta = 3]$&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Enc(00) = 000000, Enc(01) = 000111
Enc(10) = 111000, Enc(11) = 111111
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can correct 1 error during the transmission, e.g. &lt;code&gt;010111 -&amp;gt; 01&lt;/code&gt;, and we define &lt;code&gt;Dec(c)&lt;/code&gt; is the decode algorithm.&lt;/p&gt;
&lt;h3 id=&#34;rate-and-relative-distance&#34;&gt;Rate and relative distance&lt;/h3&gt;
&lt;p&gt;With $[n, k, \Delta]$ code, we introduce some terminologies:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Rate&lt;/strong&gt;: Define as $\frac{k}{n}$&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;relative distance&lt;/strong&gt;: Define as $\frac{\Delta}{n}$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;E.g. repetition code with rate $\frac{1}{a}, \Delta = a$, relative distance $\frac{1}{k}$.&lt;/p&gt;
&lt;p&gt;We want both rate and relative distance can be as high as possible, but generally there is a trade-off between them.&lt;/p&gt;
&lt;h3 id=&#34;linear-code&#34;&gt;Linear code&lt;/h3&gt;
&lt;p&gt;Linear code is a common code with a requirement: any linear combination of codewords is also a codeword.&lt;/p&gt;
&lt;p&gt;Therefore, encoding can always be represented as vector-matrix multiplication between $m$ and the generator matrix.&lt;/p&gt;
&lt;p&gt;A thing to keep in mind is that the minimum distance is the same as the codeword with the least number of non-zeros (which is called weight)&lt;/p&gt;
&lt;h3 id=&#34;reed-solomon-code&#34;&gt;Reed-Solomon Code&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Reed-Solomon&lt;/strong&gt; is a widely used error-correcting code.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The message is viewed as a unique degree $k - 1$ univariate polynomial&lt;/li&gt;
&lt;li&gt;The codeword is the &lt;strong&gt;evaluations&lt;/strong&gt; at $n$ points. For example, the codeword can be $(\omega, \omega^2, &amp;hellip;, \omega^n)$ for $n$-th root-of-unity $\omega$, where $\omega^n = 1 \mod p$&lt;/li&gt;
&lt;li&gt;The distance $\Delta = n - k + 1$. This is the best choice we can have because:
&lt;ul&gt;
&lt;li&gt;A degree $k - 1$ polynomial has at most $k - 1$ roots&lt;/li&gt;
&lt;li&gt;Since the codeword is $n$ evaluations, we subtract the number of roots from this to get the minimum number of non-zeros&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Encoding time is $\mathcal{O}(n \log n)$ using FFT&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For $n = 2k$, the rate is $\frac{1}{2}$ and relative distance is $\frac{1}{2}$.&lt;/p&gt;
&lt;h2 id=&#34;polynomial-commitment-based-on-linear-code&#34;&gt;Polynomial commitment based on linear code&lt;/h2&gt;
&lt;h3 id=&#34;polynomial-coefficients-in-a-matrix&#34;&gt;Polynomial coefficients in a matrix&lt;/h3&gt;
&lt;p&gt;To begin constructing our poly-commit scheme, we will first take a different approach on representing our polynomial. Remember that there was a &amp;ldquo;coefficient representation&amp;rdquo; where we simply stored the list of coefficients as a vector. Now, we will use a matrix to do that.&lt;/p&gt;
&lt;p&gt;Suppose that you have a polynomial $f(x)$ where $\deg(f) = d$ is a perfect square (note that if $d$ is not square, we can pad the polynomial by adding higher monomial with zero coefficient), we can write our polynomial as $$f(x) = \sum_{i=1}^{\sqrt{d}} \sum_{j = 1}^{\sqrt{d}} f_{i, j}u^{i - 1 + (j - 1) \sqrt{d}}$$&lt;/p&gt;
&lt;p&gt;With the representation below, we can rewrite the coefficients by the following matrix:&lt;/p&gt;
&lt;p&gt;$$\begin{pmatrix} f_{1, 1} &amp;amp; f_{1, 2} &amp;amp; \dots &amp;amp; f_{1, \sqrt{d}} \newline f_{2, 1} &amp;amp; f_{2, 2} &amp;amp; \dots &amp;amp; f_{2, \sqrt{d}} \newline \vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots \newline f_{\sqrt{d}, 1} &amp;amp; f_{\sqrt{d}, 2} &amp;amp; \dots &amp;amp; f_{\sqrt{d}, \sqrt{d}} \end{pmatrix}$$&lt;/p&gt;
&lt;p&gt;Evaluation of this polynomial at some point $u$ can then be shown as some matrix-vector multiplication:&lt;/p&gt;
&lt;p&gt;$$f(u) = [1, u, u^2, &amp;hellip;, u^{\sqrt{d} - 1}] \times \begin{pmatrix} f_{1, 1} &amp;amp; f_{1, 2} &amp;amp; \dots &amp;amp; f_{1, \sqrt{d}} \newline f_{2, 1} &amp;amp; f_{2, 2} &amp;amp; \dots &amp;amp; f_{2, \sqrt{d}} \newline \vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots \newline f_{\sqrt{d}, 1} &amp;amp; f_{\sqrt{d}, 2} &amp;amp; \dots &amp;amp; f_{\sqrt{d}, \sqrt{d}} \end{pmatrix} \times \begin{bmatrix} 1 \newline u^{\sqrt{d}} \newline u^{2 \sqrt{d}} \newline \vdots \newline u^{d - \sqrt{d}} \end{bmatrix}$$&lt;/p&gt;
&lt;p&gt;And with this, we will be able to reduce a polynomial commitment of proof size $\sqrt{d}$ to an argument for vector-matrix product into as shown below:&lt;/p&gt;
&lt;p&gt;$$[1, u, u^2, &amp;hellip;, u^{\sqrt{d} - 1}] \times \begin{pmatrix} f_{1, 1} &amp;amp; f_{1, 2} &amp;amp; \dots &amp;amp; f_{1, \sqrt{d}} \newline f_{2, 1} &amp;amp; f_{2, 2} &amp;amp; \dots &amp;amp; f_{2, \sqrt{d}} \newline \vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots \newline f_{\sqrt{d}, 1} &amp;amp; f_{\sqrt{d}, 2} &amp;amp; \dots &amp;amp; f_{\sqrt{d}, \sqrt{d}} \end{pmatrix} = \underbrace{[\dots]}_{\sqrt{d}}$$&lt;/p&gt;
&lt;p&gt;The prover could send this resulting vector to the verifier, and the verifier could evaluate the second step locally by using column vector made of $u$ which the verifier knows. By this way, the commitment size of degree $d$ polynomial is reduced to $\sqrt{d}$.&lt;/p&gt;
&lt;p&gt;The problem now is to somehow convince the verifier that the prover has used the correct coefficients in the 2D matrix. For that, the prover does the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Transform the $\sqrt{d} \times \sqrt{d}$ matrix into a $\sqrt{d} \times n$ matrix, where each &lt;strong&gt;row&lt;/strong&gt; of length $\sqrt{d}$ is encoded into a &lt;strong&gt;codeword&lt;/strong&gt; of length $n$ using a linear code&lt;/li&gt;
&lt;li&gt;The resulting $\sqrt{d} \times n$ matrix is committed using a &lt;strong&gt;Merkle Tree&lt;/strong&gt;, where each &lt;strong&gt;column&lt;/strong&gt; is a &lt;strong&gt;leaf&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;public parameter&lt;/strong&gt; is just made of the decided Hash function to be used in Merkle Tree, so there is no trusted setup required.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With that said, the entire algorithm can be split into two steps:&lt;/p&gt;
&lt;h4 id=&#34;proximity-test&#34;&gt;Proximity Test&lt;/h4&gt;
&lt;p&gt;For the proximity test, the Verifier sends a random vector $\overrightarrow{r} = [r_1, r_2, &amp;hellip;, r_{\sqrt{d}}]$ with size $\sqrt{d}$. Then the prover multiplies the vector with the matrix (size $\sqrt{d} \times n$) to obtain another vector of size $n$. Afterwards, the verifier asks to reveal several columns of this matrix, and the prover reveals them.&lt;/p&gt;
&lt;p&gt;With that, the verifier checks the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;The resulting vector is a codeword&lt;/strong&gt;, which should be true because any linear combination of codeword is a codeword.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Columns are as committed in the Merkle Tree.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Inner product between $\overrightarrow{r}$ and each column is consistent&lt;/strong&gt;, this is done simply by looking at the corresponding elements in the size $n$ vector.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If all these are correct, then the proximity test is passed with overwhelming probability.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Giapppp/Giapppp.github.io/main/static/images/zkp6_1.png&#34; alt=&#34;Image alt&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;soundness&#34;&gt;Soundness&lt;/h5&gt;
&lt;p&gt;To get an intuition, suppose the prover cheats, then we have two possible positions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;If he tries to use a different matrix, by the linear property of codewords, the resulting vector will not be a codeword. The first check ensures this.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If somehow prover pass the first check, the matrix still has many different locations from the correct answer. The second check ensures that columns are as committed.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If prover use the correct matrix but send a different result vector, then he can&amp;rsquo;t pass third check due to properties of Reed-Solomon.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For a formal form, a new parameter $e$ is introduced. For $e &amp;lt; \frac{\Delta}{4}$, if the commited matrix $C$ is $e$-far from any codeword (meaning that the minimum distance of all rows to any codeword in the linear code is at least $e$), then $$\Pr{[\omega = r^TC \ is \ e-close \ to \ any \ codeword ]} \le \frac{e+1}{\mathbb{F}}$$&lt;/p&gt;
&lt;p&gt;So, if $\omega = r^TC$ is $e$-far from any codeword then finally: $$\Pr{[Check \ 3 \ passes \ for \ t \ random \ columns]} \le (1 - \frac{e}{n})^t$$&lt;/p&gt;
&lt;h5 id=&#34;discovery&#34;&gt;Discovery&lt;/h5&gt;
&lt;p&gt;This test was discovered independently by the two papers:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Ligero &lt;a href=&#34;https://acmccs.github.io/papers/p2087-amesA.pdf&#34;&gt;[AHIV&#39;2017]&lt;/a&gt;: Interleaved test. Reed-Solomon code&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://eprint.iacr.org/2017/872&#34;&gt;[BCGGHJ&#39;2017]&lt;/a&gt;: Ideal linear commitment model with linear-time encodable code -&amp;gt; first SNARK with linear prover time&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;optimization&#34;&gt;Optimization&lt;/h5&gt;
&lt;p&gt;The prover can actually send a message $m$ instead of the size $n$ result vector, such that the encoding of $m$ is equal to the codeword that is the resulting vector. This is good because:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The message with size $\sqrt{d}$ is smaller than the vector of size $n$&lt;/li&gt;
&lt;li&gt;Check 1 is implicity passed&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;consistency-test&#34;&gt;Consistency Test&lt;/h4&gt;
&lt;p&gt;The algorithm for consistency test is almost the same as the optimized proximity test. The prover sends a message $m$, which is the multiplication of $\overrightarrow{u}$(that is $f(u)$) with the coefficient matrix $C$. Then, the verifier finds the encoding of this message.&lt;/p&gt;
&lt;p&gt;Columns are ensured to be the committed ones, because we have already made that check in the proximity test. Furthermore, using the same randomly picked columns (corresponding to elements in the codeword) the verifier will check whether the multiplication is consistent.&lt;/p&gt;
&lt;p&gt;In short:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;The resulting vector is a codeword&lt;/strong&gt;, true because vector was created from the encoding of $m$.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Columns are as committed in the Merkle Tree&lt;/strong&gt;, true because this was done in the previous test.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Inner product between $\overrightarrow{u}$ and each column is consistent&lt;/strong&gt;. which is checked using the same randomly picked columns (for efficiency)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Giapppp/Giapppp.github.io/main/static/images/zkp6_2.png&#34; alt=&#34;Image alt&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;soundness-intuition&#34;&gt;Soundness (intuition)&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;By the proximity test, the committed matrix $C$ is close to a codeword.&lt;/li&gt;
&lt;li&gt;There exists an extractor that extracts $F$ by Merkle tree commitment and decoding $C$, such that $\overrightarrow{u} \times F = m$ with probability $1 - \epsilon$&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;polynomial-commitment-based-on-linear-codes&#34;&gt;Polynomial commitment based on linear codes&lt;/h3&gt;
&lt;p&gt;With these tools above, we are ready to talk about the polynomial commitment based on linear codes.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Keygen&lt;/strong&gt;: Sample a hash function
&lt;ul&gt;
&lt;li&gt;Hash function are public, so this is a &lt;strong&gt;transparent setup!&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;$\mathcal{O}(1)$ complexity, transparent setup.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Commit&lt;/strong&gt;: Encode the coefficient matrix of $f$ row-wise with a linear code, compute the Merkle tree commitment.
&lt;ul&gt;
&lt;li&gt;The complexity is $\mathcal{O}(d \log d)$ field multiplications using RS code, $\mathcal{O}(d)$ using linear-time encodable code&lt;/li&gt;
&lt;li&gt;For merkle tree, we have $\mathcal{O}(d)$ for hashed, and $\mathcal{O}(1)$ commitment size&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Eval and Verify&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Proximity test&lt;/strong&gt;: random linear combination of all rows, check its consistency with $t$ random columns&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Consistency test&lt;/strong&gt;: $\overrightarrow{u} \times F = m$, encode $m$ and check its consistency with $t$ random columns&lt;/li&gt;
&lt;li&gt;$f(u) = \braket{m, \overrightarrow{u}&amp;rsquo;}$&lt;/li&gt;
&lt;li&gt;Eval take $\mathcal{O}(d)$ field operations, and can be made non-interactive using Fiat-Shamir&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This method has proof size $\mathcal{O}(\sqrt{d})$ and verifier time $\mathcal{O}(\sqrt{d})$.&lt;/p&gt;
&lt;h3 id=&#34;practice&#34;&gt;Practice&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Giapppp/Giapppp.github.io/main/static/images/zkp6_3.png&#34; alt=&#34;Image alt&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Giapppp/Giapppp.github.io/main/static/images/zkp6_4.png&#34; alt=&#34;Image alt&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;linear-time-encodable-code&#34;&gt;Linear-time encodable code&lt;/h3&gt;
&lt;h4 id=&#34;expander-graphs&#34;&gt;Expander Graphs&lt;/h4&gt;
&lt;p&gt;Expander graph is a graph that has strong connectivity properties, quantified using vertex, edge or spectral expansion. We use bipartite graph as an example: With bipartite graph, a graph that can be split in two parts such that no vertex within that sub-graph are connected.&lt;/p&gt;
&lt;p&gt;We can use an expander as a linear code by let each vertex in the left correspond to symbols of the message $m$, and let the right side correspond to symbols of the codeword.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Giapppp/Giapppp.github.io/main/static/images/zkp6_5.png&#34; alt=&#34;Image alt&#34;&gt;&lt;/p&gt;
&lt;p&gt;Note that this way is not sufficient; it fails on the &amp;ldquo;constant relative distance&amp;rdquo; requirement. Take a message with a single non-zero for example, the codeword must look the same for all such messages. Obviously, this is not the case here, because codewords symbols change depending on which symbol of the message is non-zero.&lt;/p&gt;
&lt;h4 id=&#34;lossless-expander-graph&#34;&gt;Lossless Expander Graph&lt;/h4&gt;
&lt;p&gt;Let $|L|$ be the number of vertices in the left graph, and set $|R| = \alpha |L|$ for some constant $\alpha$. In the example above, $\alpha$ is larger than 1, but in practice we actually have $0 &amp;lt; \alpha &amp;lt; 1 $. Let $g$ be the degree of a left node.&lt;/p&gt;
&lt;p&gt;For every subset $S$ of nodes on the left, the maximum possible expansion is $g|S|$. Let $\varGamma$ denote the set of neighbors for a set, i.e. $|\varGamma(S)| = g|S|$. However, this is not true for all subset, and you need to satisfiy this constraint: $$|S| \le \frac{\alpha|L|}{g}$$&lt;/p&gt;
&lt;p&gt;In practice, we use a more relaxed definition: We let the maximum expansion $|\varGamma(S)| \ge (1 - \beta)g|S|$ with the constraint $$|S| \le \frac{\delta|L|}{g}$$ for some $\delta$. In previous definition, we use $\beta = 0$ and $\delta = \alpha$.&lt;/p&gt;
&lt;h4 id=&#34;recursive-encoding-algorithm&#34;&gt;Recursive Encoding Algorithm&lt;/h4&gt;
&lt;h5 id=&#34;encoding-algorithm&#34;&gt;Encoding Algorithm&lt;/h5&gt;
&lt;p&gt;Because lossless expander itself is not enough, we will do the encoding recursively. In this case, we will start with a message $m$ of length $k = |m|$ and finish with a codeword of size $4k$. This codeword is a combination of 3 parts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The message itself, length $k$&lt;/li&gt;
&lt;li&gt;Encoded message, using a lossless expander with $\alpha = 1/2$. The resulting code has size $k/2$. This result is then encoded using an existing (assumed) encoder of rate $1/4$. The resulting codeword has length $4 \times (k \ 2) = 2k$.&lt;/li&gt;
&lt;li&gt;Another encoded message with length $k$, is generated by using a lossless expander with $\alpha = 1/2$ to encode previous codeword.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$codeword = m || c_1 || c_2$$&lt;/p&gt;
&lt;h5 id=&#34;recursive-encoding&#34;&gt;Recursive encoding&lt;/h5&gt;
&lt;p&gt;To become recursive, we can use the algorithm and repeat for $k/2$, $k/4$,&amp;hellip; until a constant size, and use any code with good distance (e.g. Reed-Solomon) to do the encoding job.&lt;/p&gt;
&lt;h5 id=&#34;sampling-of-the-lossless-expander&#34;&gt;Sampling of the lossless expander&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Giapppp/Giapppp.github.io/main/static/images/zkp6_6.png&#34; alt=&#34;Image alt&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;improvements-of-the-code&#34;&gt;Improvements of the code&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Giapppp/Giapppp.github.io/main/static/images/zkp6_7.png&#34; alt=&#34;Image alt&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;summary&#34;&gt;Summary&lt;/h3&gt;
&lt;p&gt;Polynomial commitment (and SNARK) based on linear code has the following properties:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Transparent setup, $\mathcal{O}(1)$&lt;/li&gt;
&lt;li&gt;Commit and Prover times are $\mathcal{O}(d)$ field operations&lt;/li&gt;
&lt;li&gt;Plausibly post-quantum secure with Error-Correcting Code&lt;/li&gt;
&lt;li&gt;Field agnostic&lt;/li&gt;
&lt;li&gt;Proof size is $\mathcal{O}(\sqrt{d})$, MBs, which is not good.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Zero Knowledge Proof: Polynomial Commitments based on Pairing and Discrete Log Problem</title>
      <link>http://localhost:40099/posts/zkp5/</link>
      <pubDate>Wed, 15 May 2024 00:00:00 +0000</pubDate>
      <author>michael@michaelneuper.com (Michael Neuper)</author>
      <guid>http://localhost:40099/posts/zkp5/</guid>
      <description>&lt;p&gt;In this post, we will learn deeply about polynomial commitment schemes based on Pairing and Discrete Logarithm Problem, mainly KZG, Bulletproofs and their variants.&lt;/p&gt;
&lt;h2 id=&#34;resources&#34;&gt;Resources&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://eprint.iacr.org/2017/1146&#34;&gt;A Zero-Knowledge Version of vSQL&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://eprint.iacr.org/2017/1066.pdf&#34;&gt;Bulletproofs: Short Proofs for Confidential Transactions and More&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://medium.com/@VitalikButerin/exploring-elliptic-curve-pairings-c73c1864e627&#34;&gt;Exploring Elliptic Curve Pairing - Vitalik Buterin&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://hackmd.io/@benjaminion/bls12-381&#34;&gt;BLS12-381 For The Rest of Us - Ben Edgington&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://crypto-notes-erhant.vercel.app/zklearning/poly-commits-on-pairings-with-dlog.html#kzg-poly-commit-scheme-with-pairings&#34;&gt;Poly-commits: Pairing &amp;amp; Discrete Log - Cryptonotes&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;detail&#34;&gt;Detail&lt;/h2&gt;
&lt;h3 id=&#34;background&#34;&gt;Background&lt;/h3&gt;
&lt;h4 id=&#34;group&#34;&gt;Group&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;A Group&lt;/strong&gt; is a set $\mathbb{G}$ and an operation $*$ with these properties:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Closure&lt;/strong&gt;: For all $a, b \in \mathbb{G}$, $a * b \in G$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Associativity&lt;/strong&gt;: For all $a, b, c \in \mathbb{G}$, $(a * b) * c = a * (b * c)$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Identity&lt;/strong&gt;: There exists a unique element $e \in \mathbb{G}$ such that for every $a \in \mathbb{G}$, $e * a = a * e = a$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Inverse&lt;/strong&gt;: For each $a \in \mathbb{G}$, there exists $b \in \mathbb{G}$ such that $a * b = b * a = e$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For example, $\mathbb{Z}$ under addition, $\mathbb{F}_p$ under multiplication and elliptic curves are group&lt;/p&gt;
&lt;h4 id=&#34;generator&#34;&gt;Generator&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Generator&lt;/strong&gt; is an element $g \in G$ that generates all elements in the group by taking all powers of $g$.&lt;/p&gt;
&lt;p&gt;For example, with $\mathbb{Z}^*_7 = \lbrace 1, 2, 3, 4, 5, 6 \rbrace$, $3$ is a generator, because $3^1 = 3, 3^2 = 2, 3^3 = 6, 3^4 = 4, 3^5 = 5, 3^6 = 1 \mod 7$.&lt;/p&gt;
&lt;h4 id=&#34;discrete-logarithm-assumption&#34;&gt;Discrete Logarithm Assumption&lt;/h4&gt;
&lt;p&gt;Let $\mathbb{G}$ is a group with generator $g$, so we can represent $\mathbb{G} = \lbrace g, g^2,&amp;hellip;,g^{p-1} \rbrace$. The &lt;strong&gt;discrete logarithm problem&lt;/strong&gt; is, given $y \in \mathbb{G}$, we need to find $x$ such that $g^x = y$.&lt;/p&gt;
&lt;p&gt;It turns out that this is very hard to do. There are some methods to solve this problem like Bruteforce, &lt;a href=&#34;https://en.wikipedia.org/wiki/Baby-step_giant-step&#34;&gt;Baby-Step Giant-Step&lt;/a&gt;, &lt;a href=&#34;https://en.wikipedia.org/wiki/Pohlig%E2%80%93Hellman_algorithm&#34;&gt;Pohlig-Hellman&lt;/a&gt;, &lt;a href=&#34;https://crypto.stackexchange.com/questions/52673/why-does-smarts-attack-only-work-on-anomalous-curves&#34;&gt;Smart&amp;rsquo;s attack&lt;/a&gt;,&amp;hellip; but all of them need some special requirements, so people consensus that this problem is &lt;strong&gt;computationally hard&lt;/strong&gt;.&lt;/p&gt;
&lt;h4 id=&#34;diffie-hellman-assumption&#34;&gt;Diffie-Hellman Assumption&lt;/h4&gt;
&lt;p&gt;Diffie-Hellman Key-Exchange is familiar with us, and that is based on the Diffie-Hellman Assumption, which is very similar to the discrete logarithm assumption: given $\mathbb{G}, g, g^x, g^y$, compute $g^{xy}$.&lt;/p&gt;
&lt;p&gt;This is a stronger assumption than the discrete logarithm assumption. If someone can solve discrete logarithm problem, they can easily break this assumption by calculate $x$ from $g^x$ (or $y$ from $g^y$), then calculate $g^{xy}$.&lt;/p&gt;
&lt;p&gt;This is also a hard problem and there is no efficient solution yet.&lt;/p&gt;
&lt;h4 id=&#34;bilinear-pairing&#34;&gt;Bilinear pairing&lt;/h4&gt;
&lt;p&gt;Let&amp;rsquo;s talk about &lt;strong&gt;bilinear pairing&lt;/strong&gt;. We have the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$\mathbb{G}, \mathbb{G}_T$ are both multiplicative cyclic group of order $p$, where $\mathbb{G}$ is the base group with generator $g$, and $\mathbb{G}_T$ is the target group.
Both $\mathbb{G}, \mathbb{G}_T$ have order $p$.&lt;/li&gt;
&lt;li&gt;$e$ is a &lt;strong&gt;pairing&lt;/strong&gt; operation, it is the map $e: \mathbb{G} \times \mathbb{G} \to \mathbb{G}_T$.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We are interested with the &lt;strong&gt;bilinearity&lt;/strong&gt; property: $$\forall P, Q \in \mathbb{G}: e(P^x, Q^y) = e(P, Q^y)^x = e(P^x, Q)^y = e(P, Q)^{xy}$$&lt;/p&gt;
&lt;p&gt;Note that computing $e$ itself maybe efficient or not, depends on the groups that are being used; and also note that we can use two different base groups.&lt;/p&gt;
&lt;h5 id=&#34;example-decisional-diffie-hellman&#34;&gt;Example: Decisional Diffie-Hellman&lt;/h5&gt;
&lt;p&gt;Given $g^x$ and $g^y$, a pairing can check that some element $h = g^{xy}$ without knowing $x$ and $y$.&lt;/p&gt;
&lt;h5 id=&#34;example-bls-signature&#34;&gt;Example: BLS signature&lt;/h5&gt;
&lt;p&gt;&lt;a href=&#34;https://www.iacr.org/archive/asiacrypt2001/22480516.pdf&#34;&gt;BLS signature&lt;/a&gt; is a good example of using pairing. It&amp;rsquo;s a signature scheme with these functions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$keygen(p, \mathbb{G}, g, \mathbb{G}_T, e) \to (sk = x, pk = g^x)$ is the secret key and public key, respectively.&lt;/li&gt;
&lt;li&gt;$sign(sk, m) \to \sigma = H(m)^x$ where $H$ is a cryptographic hash function that maps the message space to $\mathbb{G}$.&lt;/li&gt;
&lt;li&gt;$verify(pk, \sigma, m) \to \lbrace 0, 1 \rbrace$ will verify if $e(H(m), g^x) = e(\sigma, g)$. Notice that $g^x$ comes to $pk$, and $H$ is a known public hash function.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;kzg-polynomial-commitment-scheme&#34;&gt;KZG Polynomial Commitment Scheme&lt;/h3&gt;
&lt;p&gt;We discussed about KZG in previous post, but because we are talking about pairing, we will dig deeper about KZG Poly-commit Scheme.&lt;/p&gt;
&lt;p&gt;Suppose you have a univariate polynomial function family $\mathcal{F} = \mathbb{F}_p^{\le d}[X]$ and a polynomial you would like to commit $f \in \mathcal{F}$. You also have a bilinear pairing $p, \mathbb{G}, q, \mathbb{G}_T, e$. Let see how KZG works with these.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$keygen(\lambda, \mathcal{F}) \to gp$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sample a random $\tau \in \mathbb{F}_p$&lt;/li&gt;
&lt;li&gt;Set $gp = (g, g^\tau, g^{\tau^2},&amp;hellip;,g^{\tau^d})$&lt;/li&gt;
&lt;li&gt;Delete $\tau$. If it still exists now, malicious user can generate fake proofs. This is why a &lt;strong&gt;trusted setup&lt;/strong&gt; is required for KZG.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$commit(gp, f) \to comm_f$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The polynomial is represented with its coefficients $f(x) = f_0 + f_1x + f_2x^2 + &amp;hellip; + f_dx^d$&lt;/li&gt;
&lt;li&gt;The commitment $comm_f = g^{f(\tau)}$. We don&amp;rsquo;t know $\tau$, but by $gp$, we can calculate $comm_f = g^{f_ 0 + f_1 \tau + f_2 \tau^2 + &amp;hellip; + f_d \tau^d} = g^{f_0} \times (g^\tau)^{f_1} \times (g^{\tau^2})^{f_2} \times &amp;hellip; \times (g^{\tau^d})^{f_d}$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$eval(gp, f, u) \to v, \pi$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A verifier want to query this polynomial at point $u$, and you would like to show that $f(u) = v$ along with a proof $\pi$ that this is indeed true.&lt;/li&gt;
&lt;li&gt;We need to compute quotient polynomial $q(x)$ and $\pi = g^{q(\tau)}$ by using $gp$. $q(x)$ need to satisfy that $f(x) - f(u) = (x - u)q(x)$ and note that $u$ is a root of $f(x) - f(u)$.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$verify(gp, comm_f, u, v, \pi) \to \lbrace 0, 1 \rbrace$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The idea is check the equation at point $\tau: g^{f(\tau) - f(u)} = g^{(\tau - u)q(\tau)}$ (1).&lt;/li&gt;
&lt;li&gt;But we only know $g^{\tau - u}$ and $g^{q(\tau)}$. By Diffie-Hellman assumption, calculate $g^{(\tau - u)q(\tau)}$ from $g^{\tau - u}$ and $g^{q(\tau)}$ is very hard. That&amp;rsquo;s where pairing need to!&lt;/li&gt;
&lt;li&gt;We can use pairing to calculate $e(comm_f/g^v, g)$ and $e(g^{\tau - u}, \pi)$ and check they are equal or not. If it&amp;rsquo;s equal, then we know (1) is correct because $e(g, g)^{f(\tau) - f(u)} = e(g, g)^{(\tau - u)q(\tau)}\iff f(x) - f(u) = (x - u)q(x)$ (assume that $e(g, g) \ne 0, 1$).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;q-strong-bilinear-diffie-hellman&#34;&gt;q-Strong Bilinear Diffie-Hellman&lt;/h4&gt;
&lt;p&gt;The &lt;strong&gt;q-Strong Bilinear Diffie-Hellman (q-SBDH)&lt;/strong&gt; assumption is, given $(p, \mathbb{G}, g, \mathbb{G}_T, e), gp = (g, g^\tau, g^{\tau^2},&amp;hellip;,g^{\tau})$, it is &lt;strong&gt;computationally hard&lt;/strong&gt; to compute $e(g, g)^{\frac{1}{\tau - u}}$ for any $u$.&lt;/p&gt;
&lt;p&gt;Remember two properties of KZG ? They are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Correctness&lt;/strong&gt;: If the prover is honest, then the verifier will always accept.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Soundness&lt;/strong&gt;: How likely is a fake proof to be verified?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We can see proof of soundness in the lecture:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Giapppp/Giapppp.github.io/main/static/images/zkp5_1.png&#34; alt=&#34;Image alt&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;knowledge-of-exponent-koe&#34;&gt;Knowledge of Exponent (KoE)&lt;/h4&gt;
&lt;p&gt;How we can assume the prover knows $f$ such that $comm_f = g^{f(\tau)}$ ? Here is how:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$gp = (g, g^\tau, g^{\tau^2},&amp;hellip;,g^{\tau})$&lt;/li&gt;
&lt;li&gt;Sample some random $\alpha$ and compute $gp^\alpha = (g^\alpha, g^{\alpha \tau}, g^{\alpha \tau^2},&amp;hellip;,g^{\alpha \tau^d})$&lt;/li&gt;
&lt;li&gt;Compute two commitments instead of one, $comm_f = g^{f(\tau)}$ and $comm_f&amp;rsquo; = g^{\alpha f(\tau)}$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With bilinear pairing, if $e(comm_f, g^\alpha) = e(comm_f&amp;rsquo;, g)$ there exists an extractor $E$ that extracts $f$ such that $comm_f = g^{f(\tau)}$. This extractor will extract $f$ in our proof above, where we assumed the prover knows $f$.&lt;/p&gt;
&lt;p&gt;So, let&amp;rsquo;s describe KZG with knowledge soundness:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Keygen&lt;/strong&gt;: $gp$ include both $(g, g^\tau, g^{\tau^2},&amp;hellip;,g^{\tau})$ and $(g^\alpha, g^{\alpha \tau}, g^{\alpha \tau^2},&amp;hellip;,g^{\alpha \tau^d})$&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Commit&lt;/strong&gt;: $comm_f = g^{f(\tau)}, comm_f&amp;rsquo; = g^{\alpha f(\tau)}$&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Verify&lt;/strong&gt;: checks $e(comm_f, g^\alpha) = e(comm_f&amp;rsquo;, g)$&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Knowledge soundness proof&lt;/strong&gt;: Extract $f$ in the first step by the KoE assumption.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;generic-group-model-ggm&#34;&gt;Generic group model (GGM)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;In informal definition, adversary is only give an oracle to compute the group operation, like given $(g, g^\tau, g^{\tau^2},&amp;hellip;,g^{\tau^d})$, adversary can only compute their linear combinations.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GGM can replace the KoE assumption and reduce the commitment size in KZG.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;property-of-the-kzg-poly-commit&#34;&gt;Property of the KZG poly-commit&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Keygen&lt;/strong&gt;: trusted setup!&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Commit&lt;/strong&gt;: $\mathcal{O}(d)$ group exponentiations, $\mathcal{O}(1)$ commitment size&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Eval&lt;/strong&gt;: $\mathcal{O}(d)$ group exponentiations, and quotient $q(x)$ can be computed efficiently in linear time&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Proof size&lt;/strong&gt;: $\mathcal{O}(1)$, 1 group element&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Verifier time&lt;/strong&gt;: $\mathcal{O}(1)$, 1 pairing&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;ceremony&#34;&gt;Ceremony&lt;/h4&gt;
&lt;p&gt;To relax the trusted setup in practice, there is a process called &lt;strong&gt;ceremony&lt;/strong&gt;. The goal of ceremony is to have a distributed generation of the global parameters so that no one can reconstruct the trapdoor if at least one of the participants is honest and discards their secrets. Here is how to do it:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Suppose your global parameters are $gp = (g^{\tau}, g^{\tau^2},&amp;hellip;,g^{\tau^d}) = (g_1, g_2, &amp;hellip;, g_d)$&lt;/li&gt;
&lt;li&gt;As a participant in this ceremony, you sample random $s$ and update $gp&amp;rsquo; = (g_1&amp;rsquo;, g_2&amp;rsquo;, &amp;hellip;, g_d&amp;rsquo;) = (g_1^s, g_2^{s^2},&amp;hellip;,g_d^{s^d}) = (g^{\tau s}, g^{(\tau s)^2}, &amp;hellip;,g^{(\tau s)^d})$ with secret $\tau s$&lt;/li&gt;
&lt;li&gt;Check the correntness of $gp&#39;$&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;The contributor knows $s$ such that $g_1&amp;rsquo; = (g_1)^s$&lt;/li&gt;
&lt;li&gt;$gp&amp;rsquo;$ consists of consecutive powers $e(g_i&amp;rsquo;, g_1&amp;rsquo;) = e(g_{i+1}&amp;rsquo;, g)$ and $g_1&amp;rsquo; \ne 1$
To know more, check &lt;a href=&#34;https://eprint.iacr.org/2022/1592.pdf&#34;&gt;Nikolaenko-Ragsdale-Bonneau-Boneh&#39;22&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;variants-of-kzg-poly-commit&#34;&gt;Variants of KZG poly-commit&lt;/h3&gt;
&lt;h4 id=&#34;multivariate-poly-commit&#34;&gt;Multivariate poly-commit&lt;/h4&gt;
&lt;p&gt;This was described first in &lt;a href=&#34;https://eprint.iacr.org/2011/587.pdf&#34;&gt;Papamanthou-Shi-Tamassia&#39;13&lt;/a&gt;. In this paper, they explains a way to use KZG for multivariate polynomial. The key idea is: $$f(x_1, &amp;hellip;, x_k) - f(u_1, &amp;hellip;, u_k) = \sum_{i=1}^k(x_i - u_i)q_i(\overrightarrow{x})$$&lt;/p&gt;
&lt;p&gt;We have these properties:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Keygen&lt;/strong&gt;: sample $\tau_1, \tau_2,&amp;hellip;,\tau_k$, compute $gp$ as $g$ raised to all possible monomials of $\tau_1, \tau_2,&amp;hellip;,\tau_k$&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Commit&lt;/strong&gt;: $comm_f = g^{f(\tau_1, \tau_2,&amp;hellip;,\tau_k)}$&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Eval&lt;/strong&gt;: compute $\pi_i = g^{q_i(\overrightarrow{x})}$&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Verify&lt;/strong&gt;: $e(comm_f/g^v, g) = \prod_{i=1}^ke(g^{\tau_i - u_i}, \pi_i)$&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;achieving-zero-knowledge&#34;&gt;Achieving zero-knowledge&lt;/h4&gt;
&lt;p&gt;Plain KZG is not zero-knowledge, e.g. $comm_f = g^{f(\tau)} is deterministic. Also remember that to formally show zero-knowledgeness, we need a simulator construction that can simulate the view of the commitment scheme.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://home.cse.ust.hk/~dipapado/docs/vram.pdf&#34;&gt;ZGKPP&#39;18&lt;/a&gt; shows a method to do this by masking with randomizers.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Commit&lt;/strong&gt;: $comm_f = g^{f(\tau) + r \eta}$&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Eval&lt;/strong&gt;: $f(x) + ry - f(u) = (x - u)(q(x) + r&amp;rsquo;y) + y(r - r&amp;rsquo;(x - u))$, and the proof will be $\pi = g^{q(\tau) + r&amp;rsquo;\eta}, g^{r - r&amp;rsquo;(\tau - u)}$.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;batch-opening-single-polynomial&#34;&gt;Batch opening: single polynomial&lt;/h4&gt;
&lt;p&gt;Prover wants to prove $f$ at $u_1,&amp;hellip;,u_m$ for $m &amp;lt; d$. The key idea is:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Extrapolate $f(u_1), f(u_2),&amp;hellip;,f(u_m)$ to obtain $h(x)$.&lt;/li&gt;
&lt;li&gt;Find a quotient polynomial from $f(x) - h(x) = \prod _{i=1}^m(x-u_i)q(x)$&lt;/li&gt;
&lt;li&gt;The proof then becomes $\pi = g^{q(\tau)}$&lt;/li&gt;
&lt;li&gt;Now, the verifier will check $e(comm_f/g^{h(\tau)}, g) = e(g^{\prod _{i=1}^m(x-u_i)}, \pi)$&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;batch-opening-multiple-polynomials&#34;&gt;Batch opening: multiple polynomials&lt;/h4&gt;
&lt;p&gt;Prover wants to prove $f_i(u_{i, j}) = v_{i, j}$ for $i \in [n], j \in [m]$. The key idea is:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Extrapolate $f_i(u_1), &amp;hellip;, f_i(u_m)$ to get $h_i(x)$ for $i \in [n]$&lt;/li&gt;
&lt;li&gt;Find quotient polynomials from $f_i(x) - h_i(x) = \prod_{i=1}^m(x - u_m)q_i(x)$&lt;/li&gt;
&lt;li&gt;Combine all $q_i(x)$ via a random linear combination.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;polynomial-commitments-based-on-discrete-logarithm&#34;&gt;Polynomial commitments based on discrete logarithm&lt;/h3&gt;
&lt;h4 id=&#34;bulletproofs&#34;&gt;Bulletproofs&lt;/h4&gt;
&lt;p&gt;Although KZG polynomial commitment is very effective, but require trusted setup is still a problem to solve. &lt;strong&gt;Bulletproofs&lt;/strong&gt;[&lt;a href=&#34;https://eprint.iacr.org/2016/263.pdf&#34;&gt;BCCGP&#39;16&lt;/a&gt;], [&lt;a href=&#34;https://eprint.iacr.org/2017/1066.pdf&#34;&gt;BBBPWM&#39;18&lt;/a&gt;] is one of proof schemes without trusted setup.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;$keygen$&lt;/strong&gt;: Bulletproofs have a transparent setup, which sample random $gp = (g_0, g_1, &amp;hellip;, g_d)$ in $\mathbb{G}$
&lt;strong&gt;$commit(gp, f) \to comm_f$&lt;/strong&gt;: Suppose you want to commit $f(x) = f_0 + f_1x + f_2x^2 + &amp;hellip; + f_dx^d$, then your commitment will be $comm_f = g_0^{f_0}g_1^{f_1}g_2^{f_2}&amp;hellip;g_d^{f_d}. Notice that this is a &amp;ldquo;vector commitment&amp;rdquo; version of a Pedersen Commitment
&lt;strong&gt;$eval(gp, f, u)$&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Find $v = f(u)$&lt;/li&gt;
&lt;li&gt;Compute $L, R, v_L, v_R$, where $L, R$ are commitments of left half and right half of polynomial.&lt;/li&gt;
&lt;li&gt;Receive a random $r$ from verifier and reduce $f$ to $f&amp;rsquo;$ of degree $d/2$&lt;/li&gt;
&lt;li&gt;Upgrade the bases $gp&amp;rsquo;$
&lt;strong&gt;$verify(gp, comm_f, u, v, \pi)$&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;Check $v = v_L + v_R * u^{d/2}&lt;/li&gt;
&lt;li&gt;Generate $r$ randomly&lt;/li&gt;
&lt;li&gt;Update $comm&amp;rsquo; = L^r * comm_f * R^{r^{-1}}$ (magic trick)&lt;/li&gt;
&lt;li&gt;Update the global parameter to be $gp&#39;$&lt;/li&gt;
&lt;li&gt;Set $v&amp;rsquo; = rv_L + r_R$
Note that we do $eval$ and $verify$ recursively around $\log d$ times.
The idea of Bulletproofs is to recursively divide a polynomial in two polynomials, and commit to those smaller polynomials.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Giapppp/Giapppp.github.io/main/static/images/zkp5_2.png&#34; alt=&#34;Image alt&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;properties-of-bulletproofs&#34;&gt;Properties of Bulletproofs&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Keygen&lt;/strong&gt;: $\mathcal{O}(d)$, transparent setup&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Commit&lt;/strong&gt;: $\mathcal{O}(d)$ group exponentiations, $\mathcal{O}(1)$ commitment size&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Eval&lt;/strong&gt;: $\mathcal{O}(d)$ group exponentiations (non-interactive via Fiat-Shamir)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Proof size&lt;/strong&gt;: $\mathcal{O}(\log d)$&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Verifier time&lt;/strong&gt;: $\mathcal{O}(d)$&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;other-protocols&#34;&gt;Other protocols&lt;/h4&gt;
&lt;h5 id=&#34;hyrax-wahby-tzialla-shelat-thaler-walfish18httpseprintiacrorg20171132pdf&#34;&gt;Hyrax &lt;a href=&#34;https://eprint.iacr.org/2017/1132.pdf&#34;&gt;Wahby-Tzialla-Shelat-Thaler-Walfish&#39;18&lt;/a&gt;&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Improves the verifier time to $\mathcal{O}(\sqrt{d})$ by representing the coefficients as a 2-D matrix.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Proof size: $\mathcal{O}(\sqrt{d})$.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;dory-lee21httpseprintiacrorg20201274&#34;&gt;Dory &lt;a href=&#34;https://eprint.iacr.org/2020/1274&#34;&gt;Lee&#39;21&lt;/a&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Improving verifier time to $\mathcal{O}(\log d)$.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The key idea is delegating the structured verifier computation to the prover using inner pairing product arguments [&lt;a href=&#34;https://eprint.iacr.org/2019/1177.pdf&#34;&gt;BMMTV&#39;21&lt;/a&gt;].&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Also improves the prover time to $\mathcal{O}(\sqrt{d})$ exponentiations plus $\mathcal{O}(d)$ field operations.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;dark-bünz-fisch-szepieniec20httpseprintiacrorg20191229&#34;&gt;Dark &lt;a href=&#34;https://eprint.iacr.org/2019/1229&#34;&gt;Bünz-Fisch-Szepieniec&#39;20&lt;/a&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Achieves $\mathcal{O}(\log d)$ proof size and verifier time&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Group of unknown order&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;summary&#34;&gt;Summary&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Giapppp/Giapppp.github.io/main/static/images/zkp5_3.png&#34; alt=&#34;Image alt&#34;&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Zero Knowledge Proof: The PLONK SNARK</title>
      <link>http://localhost:40099/posts/zkp4/</link>
      <pubDate>Thu, 25 Apr 2024 00:00:00 +0000</pubDate>
      <author>michael@michaelneuper.com (Michael Neuper)</author>
      <guid>http://localhost:40099/posts/zkp4/</guid>
      <description>&lt;p&gt;In this posts, we will construct a widely used SNARK called PLONK&lt;/p&gt;
&lt;h2 id=&#34;resources&#34;&gt;Resources&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://eprint.iacr.org/2019/953&#34;&gt;PLONK: Permutations over Lagrange-bases for Oecumenical Noninteractive arguments of Knowledge&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://alinush.github.io/2021/06/17/Feist-Khovratovich-technique-for-computing-KZG-proofs-fast.html&#34;&gt;Feist-Khovratovich technique for computing KZG proofs fast&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://crypto-notes-erhant.vercel.app/zklearning/the-PLONK-snark.html&#34;&gt;Cryptonotes - Erhant&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;detail&#34;&gt;Detail&lt;/h2&gt;
&lt;h3 id=&#34;recall-polynomial-commitment&#34;&gt;Recall: Polynomial Commitment&lt;/h3&gt;
&lt;p&gt;If you don&amp;rsquo;t know anything about polynomial commitment, I suggest reading &lt;a href=&#34;https://giapppp.github.io/posts/zkp3/&#34;&gt;my previous post&lt;/a&gt;. Here is a short explanation about what they are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The prover would like to commit to some polynomial $f \in \mathbb{F}_p^{\le d}[X]$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;An $eval$ finction uses evaluate some values for this polynomial, without revealing it. For example, pick some public $u, v \in \mathbb{F}_p$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Prover will convince that $f(u) = v$ and $deg(f) \le d$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Verifier will only know $d, u, v$ and a polynomial commitment $comm_f$, also shown as $f$ sometimes&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The proof size for $eval$ and the verifier time should both be in $\mathcal{O}_{\lambda}(\log d)$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;the-kzg-polynomial-commitment-scheme&#34;&gt;The KZG polynomial commitment scheme&lt;/h3&gt;
&lt;p&gt;Let&amp;rsquo;s talk about KZG [&lt;a href=&#34;https://www.iacr.org/archive/asiacrypt2010/6477178/6477178.pdf&#34;&gt;Kate-Zaverucha-Goldberg&#39;10&lt;/a&gt;] polynomial commitment scheme. We will work with finite cyclic group $\mathbb{G}$ of order $p$ with generator $g$&lt;/p&gt;
&lt;h4 id=&#34;trusted-setup-setuplambda-to-gp&#34;&gt;Trusted Setup: $setup(\lambda) \to gp$&lt;/h4&gt;
&lt;p&gt;KZG starts with a trusted setup $setup(\lambda) \to gp$ to produce public parameters. This is done as follows:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Sample some random $\tau \in \mathbb{F}_p$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Calculate public parameters $gp$: $$gp = (H_0 = g, H_1 = \tau g,..,H_d = \tau^d g) \in \mathbb{G}^{d+1}$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;and we will have $|gp| = d + 1$&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Delete $\tau$. If this number is leaked and in wrong hands, they can create fake proofs. This is why the setup must take place in a trusted environment.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;commitment-commitgp-f-to-comm_f&#34;&gt;Commitment: $commit(gp, f) \to comm_f$&lt;/h4&gt;
&lt;p&gt;A commitment will take the public parameters $gp$ along with the polynomial $f$ to be committed, and produces the commitment&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The commitment is shown as $commit(gp, f) \to comm_f$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Our commitment will be $comm_f = f(\tau)g \in \mathbb{G}$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;How to calculate $f(\tau)$ without knowledge of $\tau$?. Let&amp;rsquo;s take a look about the function $f$: $$f(X) = f_0 + f_1X + f_2X^2 + &amp;hellip; + f_dX^d$$&lt;/p&gt;
&lt;p&gt;Remember that we know $H_i = X^i, i = 0..d$, so we can calculate: $$f_0  H_0 + f_1  H_1 + &amp;hellip; + f_d  H_d$$&lt;/p&gt;
&lt;p&gt;When you expand $H_i$, you will see that: $$f_0g + f_1 \tau g + f_2 \tau^2 g + &amp;hellip; + f_d \tau^d g = f(\tau)g$$&lt;/p&gt;
&lt;p&gt;And you get the commitment you want! Note that this commitment is &lt;strong&gt;binding&lt;/strong&gt; but not &lt;strong&gt;hiding&lt;/strong&gt; as is.&lt;/p&gt;
&lt;h4 id=&#34;evaluation-eval&#34;&gt;Evaluation: $eval$&lt;/h4&gt;
&lt;p&gt;Let us now see how a verifier evaluates the commitment&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Prover knows $(gp, f, u, v)$ and wants to prove that $f(u) = v$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Verifier knows $(gp, comm_f, u, v)$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We will use some well-known properties of polynomial:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$f(u) = v$ if and only if $u$ is a root of $\hat{f} = f - v$.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$u$ is a root of $\hat{f}$ if and only if the polynomial $(X - u)$ divides $\hat{f}$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$(X - u)$ divides $\hat{f}$ if and only if $\exist q \in \mathbb{F}_p[X]$ such that $q(X)(X - u) = \hat{f}(X) = f(X) - v$. This is another way of saying that since $(X - u)$ divides $\hat{f}$ there will be no remainder left from this division, and there will be some resulting quotient polynomial $q$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now we can talk about the plan:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Prover computes $q(X)$ and commits to $q$ as $comm_q$. Remember that commitment results in a single group element only&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Prover send the proof $\pi = comm_q$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Verifier accepts if $(\tau - u) comm_q = comm_f - vg$&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;You can see the appearance of $\tau$ here, which is supposed to be secret. Well, we use &lt;strong&gt;pairing&lt;/strong&gt; to hide $\tau$ while still allowing the above computation. In doing so, only $H_0$ and $H_1$ will be used, which makes this thing independent of degree $d$&lt;/p&gt;
&lt;p&gt;Actually, we still need $d$. The prover must compute the quotient polynomial $q$ and the complexity of that is related to $d$, so you will lose from prover time when you have large degrees&lt;/p&gt;
&lt;p&gt;To prove that this is a secure poly-commit scheme, we need to dig deeper
about polynomial commitments, which will be described in my next post&lt;/p&gt;
&lt;h4 id=&#34;properties-of-kzg&#34;&gt;Properties of KZG&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Generalizations:&lt;/strong&gt; It has been shown that you can use KZG to commit to $k$-variate polynomials&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Batch Proofs:&lt;/strong&gt; Suppose you have commitments to $n$ polynomials $f_1, f_2, &amp;hellip;, f_n$ and you have $m$ values to reveal in each of them, meaning that you basically want to prove all evaluations defined by $f_i(u_{i,j}) = v_{i, j}$ for $i \in [n]$ and $j \in [m]$. Normally, this would require $n \times m$ evaluations, but thanks to KZG we can actually do this in a single proof that is a single group element&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Linear-time Commitments:&lt;/strong&gt; We have several ways to represent a polynomial $f(X)$ in $\mathbb{F}_p^{(\le d)}[X]$:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Coefficient representation:&lt;/strong&gt; We will store $f(X) = f_0 + f_1X + &amp;hellip; + f_dX^d$ as an array of values $[f_0, f_1,&amp;hellip;,f_d]$. So we can compute the commitment in linear time $\mathcal{O}(d)$ since we just have to multiply $f_i$ with $H_i$ for $i \in [d]$, giving us $comm_f = f_0H_0 + f_1H_1 + &amp;hellip; + f_dH_d$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Point-value representation with NTT(Number Theoristic Transfrom):&lt;/strong&gt; A polynomial of degree $d$ can be defined by $d + 1$ points. So we have $d + 1$ points: $(a_0, f(a_0)), (a_1, f(a_1)),&amp;hellip;,(a_d, f(a_d))$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;To compute $comm_f$ naively, we can construct the coefficients $f_0, f_1, &amp;hellip;,f_d$ to basically convert point-value representation to coefficient representation, then compute the commitment&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We can use Number Theoretic Transfrom (NTT), which is closely related to Fourier Transform, to convert from point-value to coefficient representation. The complexity is $\mathcal{O}(d \log d)$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Point-value representation with Lagrange Interpolation:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;We can use Lagrange Interpolation to speed up our commitment computing! So we have: $$\begin{aligned} f(\tau) &amp;amp;= \sum _ {i=0}^{d} \lambda _ i(\tau) f(a _ i) \newline \lambda _ i (\tau) &amp;amp;= \frac{\prod ^ d _ {j = 0, j \ne i} (\tau - a_j)}{\prod ^ d _ {j = 0, j \ne i} (a_i - a_j)} \in \mathbb{F}_p \end{aligned}$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The idea here is that our public parameters will actually be in Lagrange form, and the process of getting this just a linear transformation that everyone can do. So, we obtain public parameter $\hat{gp}$ that looks like: $$\hat{gp} = (\hat{H}_0 = \lambda_0(\tau)g, \hat{H}_1 = \lambda_1(\tau)g, &amp;hellip;, \hat{H}_d = \lambda_d(\tau)g) \in \mathbb{G}^{d+1}$$ This way, the commitment can be compute in linear time $\mathcal{O}(d)$: $$comm_f = f(\tau)g = f(a_0)\hat{H}_0 + f(a_1)\hat{H}_1 + &amp;hellip; + f(a_d)\hat{H}_d$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;kzg-fast-multi-point-proof-generation&#34;&gt;KZG fast multi-point proof generation&lt;/h4&gt;
&lt;p&gt;Let $\Omega \subseteq \mathbb{F}_p$ and $|\Omega| = d$. Suppose that the prover needs an evaluation proofs $\pi_a \in G$ &lt;u&gt;for all&lt;/u&gt; $a \in \Omega$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;With a naive way, this takes time $\mathcal{O}(d^2)$, because $d$ proofs each takes time $\mathcal{O}(d)$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Thankfully, we can use &lt;a href=&#34;https://eprint.iacr.org/2023/033&#34;&gt;Feist-Khovratovich&#39;23&lt;/a&gt; to do this: If $\Omega$ is a multiplicative subgroup, the evaluation takes time in $\mathcal{O}(d \log d)$, otherwise, it takes time in $\mathcal{O}(d \log^2 d)$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;dory-poly-commit-scheme&#34;&gt;Dory Poly-commit Scheme&lt;/h4&gt;
&lt;p&gt;We have some difficulties with KZG:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Requires a trusted setup to compute the public parameters $gp$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$gp$ size is linear in the degree $d$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To deal with that hurdle, we can use Dory &lt;a href=&#34;https://eprint.iacr.org/2020/1274.pdf&#34;&gt;Lee&#39;20&lt;/a&gt;. It has some properties:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Transparent setup:&lt;/strong&gt; No secret randomness in setup&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;$comm_f$&lt;/strong&gt; is a single group element, independent of degree&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$eval$ proof size for $f \in \mathbb{F}_p^{\le d}[X]$ is $\mathcal{O}(\log d)$ group element, while KZG&amp;rsquo;s $eval$ proof size is constant&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$eval$ verify time is $\mathcal{O}(\log d)$, KZG took constant time&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;prover time is $\mathcal{O}(d)$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;pcs-to-commit-to-a-vector&#34;&gt;PCS to Commit to a Vector&lt;/h4&gt;
&lt;p&gt;We will talk about &lt;strong&gt;vector commitment&lt;/strong&gt;, which is a drop-in replacement for Merkle Trees&lt;/p&gt;
&lt;p&gt;Suppose that Bob want to commit a vector $(u_1, &amp;hellip;, u_k) \in \mathbb{F}_p^{(\le d)}$. He can interpolate a polynomial $f$ such that $f(i) = u_i$ for $i = 1,..,k$ and commit $f$ as we have described above&lt;/p&gt;
&lt;p&gt;If Alice wants to query some elements like &amp;ldquo;show me that $u_2 = a$ and $u_4 = b$&amp;rdquo;, it is equivalent to &amp;ldquo;show me $f(2) = a$ and $f(4) = b$&amp;rdquo; and we know we can prove this in a single group element using batch proof, which is a very cool property of KZG&lt;/p&gt;
&lt;p&gt;When we use a Merkle Tree, each evaluation proof would have size $\mathcal{O}(\log k)$ and for $l$ proofs this would mean $\mathcal{O}(l \log k)$ proof size, a lot bigger than the constant proof size of KZG.&lt;/p&gt;
&lt;p&gt;For more applications of using PCS in Merkle Trees, you can check &lt;a href=&#34;https://blog.ethereum.org/2021/12/02/verkle-tree-structure&#34;&gt;Verkle Tree&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;proving-properties-of-committed-polynomials&#34;&gt;Proving properties of committed polynomials&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Notation:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;When we say the verifier queries a polynomial $f$ at some random point $r$ to get $f(r)$, we actually mean that the prover computes $y = f(r)$ and a proof of this evaluation $\pi_f$, then it sends back $y, \pi_f$ to the verifier&lt;/p&gt;
&lt;p&gt;Everything we will do in our interactive proofs will be public-coin protocols, so we can compile it into non-interactive protocols using Fiat-Shamir&lt;/p&gt;
&lt;h4 id=&#34;equality-testing&#34;&gt;Equality Testing&lt;/h4&gt;
&lt;p&gt;In KZG, to test if $f = g$, verifier only need to know $comm_f, comm_g$. But this isn&amp;rsquo;t enough for more complex equality tests&lt;/p&gt;
&lt;p&gt;For example, suppose that the verifier want to see if $f = g_1 g_2 g_3$ and has $comm_f, comm_{g_1}, comm_{g_2}, comm_{g_3}$. The verifier need to query all four polynomial at random $r \in \mathbb{F}_p$ and test equality, and this takes lots of work !&lt;/p&gt;
&lt;h4 id=&#34;important-proof-gadgets-for-univariates&#34;&gt;Important Proof Gadgets for Univariates&lt;/h4&gt;
&lt;p&gt;Let $\Omega$ be some subset of $\mathbb{F}_p$ of size $k$&lt;/p&gt;
&lt;p&gt;First, we need to know about the &lt;strong&gt;vanishing polynomial&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Definition:&lt;/strong&gt; The vanishing polynomial of $\Omega$ is $$
Z_{\Omega}(X) := \prod _ {a \in \Omega}(X - a)$$ with $deg(Z_{\Omega}) = k$&lt;/p&gt;
&lt;p&gt;Then, let $\omega$ be a primitive $k$-th root of unity, meaning that $\omega^k = 1$. If the set $\Omega$ is defined as follows: $$\Omega = \lbrace 1, \omega, \omega^2,&amp;hellip;, \omega^{k - 1} \rbrace \subseteq \mathbb{F} _ p$$ then $Z_{\Omega}(X) = X^k - 1$.&lt;/p&gt;
&lt;p&gt;For $r \in \mathbb{F} _ p$, evaluating $Z_{\Omega}(r)$ takes $\le 2 \log _ 2 k$ field operations, thanks to multiply-and-square method&lt;/p&gt;
&lt;p&gt;Now, we will construct efficient poly-IOPs for the following proof gadgets: Let $f, g \in \mathbb{F}_p^{(\le d)}[X]$ be polynomials of degree $d$ and $d \ge k$. The verifier has a commitment to these polynomials, $comm_f$ and $comm_g$. Our proof gadgets will have:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Equality Test:&lt;/strong&gt; prove that $f, g$ are equal. We know that evaluating them at a random point and seeing if they are equal does the trick, assuming degree is much smaller than the size of the finite field.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Zero Test:&lt;/strong&gt; prove that $f$ is identically zero on $\Omega$, meaning that it acts like a zero-polynomial for every value in $\Omega$, but of course it can do whatever it wants for values outside of $\Omega$ but in $\mathbb{F}_p$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Sum Check:&lt;/strong&gt; prove that $\sum_{a \in \Omega}f(a) = 0$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Product Check:&lt;/strong&gt; prove that $\prod_{a \in Omega}f(a) = 1$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Permutation Check:&lt;/strong&gt; prove that evaluations of $f$ over $\Omega$ is a permutation of evaluations of $g$ over $\Omega$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Prescribed Permutation Check:&lt;/strong&gt; prove that evaluations of $f$ over $\Omega$ is a permutation of evaluations of $g$ over $\Omega$, with a &amp;ldquo;prescribed&amp;rdquo; permutation $W: \Omega \to \Omega$. This permutation is a bijection $\forall i \in [k]: W(\omega^i) = \omega^j$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;zero-test&#34;&gt;Zero Test&lt;/h5&gt;
&lt;p&gt;To understand Zero Test, we need to know about a simple but useful lemma&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lemma:&lt;/strong&gt; $f$ is zero on $\Omega$ if and only if $f(X)$ is divisible by $Z_{\Omega}(X)$&lt;/p&gt;
&lt;p&gt;Now we are ready!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Setup:&lt;/strong&gt; $P$ has a polynomial $f \in \mathbb{F}^{(\le d)} _ p[X], deg(f) = d$ and $V$ has $comm_f$. $V$ wants to prove that $f$ is zero in $\Omega$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Protocol:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The prover $P$ will calculate $q(X) = f(X)/Z_{\Omega}(X)$ and send $q$ to the verifier. Note that if $f(X)$ is not zero, then $q(X)$ isn&amp;rsquo;t a polynomial.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The verifier $V$ want to check $q$ is the quotient of $f(X)/Z_{\Omega}(X)$, so $V$ will choose random $r \in \mathbb{F}_p$, then query $q(X)$ and $f(X)$ at $r$. By the way, $V$ can learn $q(r), f(r)$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$V$ will accept if $f(r) = q(r) * Z_{\Omega}(r)$, this implies that $f(X) = q(X) * Z_{\Omega}(r)$ with high probability&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Giapppp/Giapppp.github.io/main/static/images/zkp4_1.png&#34; alt=&#34;Image alt&#34;&gt;&lt;/p&gt;
&lt;p&gt;Because $V$ need to evaluate $Z_{\Omega}(r)$ by itself, so we want the vanishing polynomial to be efficiently computable so the verifier can do this quickly. In this situation, our $Z_{\Omega}(r)$ can be calculated fast by square-and-multiply method.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Theorem:&lt;/strong&gt; This protocol is complete and sound, assuming $\frac{d}{p}$ is negligible&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s analyze the costs in this IOP:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;For Verifier: $\mathcal{O}(\log k)$ and two poly queries, but can be done in one, thanks to KZG property&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;For Prover: Dominated by the time to compute $q(X)$ and then commit to $q(X)$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;product-check-and-sum-check&#34;&gt;Product Check and Sum Check&lt;/h5&gt;
&lt;p&gt;Because Prod-check and sum-check are almost identical, so we will only look at prod-check. Again, our claim is that $\prod_{a \in \Omega} f(a) = 1$ and we would like to prove that&lt;/p&gt;
&lt;p&gt;Set $t \in \mathbb{F}^{(\le k)}_p[X]$ to be the degree-$k$ polynomial. Define the evaluations of this polynomial as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$t(1) = f(1)$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$t(\omega^s) = \prod_{i=0}^s f(\omega^i), s = 1,..,k-1$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We can notice the recurrence relation between $t$ and $f$: $$ \forall x \in \Omega: t(\omega x) = t(x) f(\omega x)$$ for all $x \in \Omega$ (including at $x = \omega^{k-1}$)&lt;/p&gt;
&lt;p&gt;We need a lemma to build this IOP:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lemma:&lt;/strong&gt; If $t(\omega^{k-1}) = 1$ and $t(\omega x) - t(x) f(\omega x) = 0$ for all $x \in \Omega$, then $\prod_{a \in \Omega}f(a) = 1$&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s write the interactive proof! The idea will to construct another polynomial $t_1(X)$ which is: $$t_1(X) = t(\omega X) - t(x) f(\omega X)$$ which implies that if a zero-test on $t_1(X)$ for $\Omega$ passes, then prod-check passes&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Setup:&lt;/strong&gt; $P$ has a polynomial $f \in \mathbb{F}^{(\le d)} _ p[X], deg(f) = d$ and $V$ has $comm_f$. $V$ wants to prove that $\prod_{a \in Omega}f(a) = 1$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Protocol:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$P$ will constructs $t(X) \in \mathbb{F}_p^{(\le k)}$ and $t_1(X) = t(\omega X) - t(X) f(\omega X)$. The prover also sets $q(X) = t_1(X) / (X^k - 1) \in \mathbb{F}_p^{(\le d)}$ and send $comm_t, comm_q$ to the verifier. Note that $t_1(X)$ should be zero on $\Omega$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The verifier $V$ will choose random $r \in \mathbb{F}_p$, then query $t(X)$ at $\omega^{k-1}, r, \omega r$ to learn $t(\omega^{k-1}), t(r), t(\omega r)$ and query $q(X), f(X)$ at $r$ and $\omega r$ respectively, to learn $q(r)$ and $f(\omega r)$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The verifier will accept if $t(\omega^{k-1}) = 1$ and $t(\omega r) - t(r) f(\omega r) = q(r) (r^k - 1)$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Giapppp/Giapppp.github.io/main/static/images/zkp4_2.png&#34; alt=&#34;Image alt&#34;&gt;&lt;/p&gt;
&lt;p&gt;The cost of this protocol is as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Proof size is two commitments $comm_q, comm_t$ and five evaluations. Keeping in mind that evaluations can be batched, the entire proof is just 3 group elements&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Prover time is dominated by computing $q(X)$ that runs in time $\mathcal{O}(k \log k)$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Verifier time is dominated by computing $r^k - 1$ and $\omega^{k-1}$, both in time $\mathcal{O}(\log k)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note that this protocol works for &lt;strong&gt;rational functions&lt;/strong&gt;. Our claim will be $\prod_{a \in \Omega}(f/g)(a) = 1$ and we construct a similar $t$ polynomial, only this time $f(x)$ is divided by $g(x)$ in the definition, then the lemma is also similar:  If $t(\omega^{k-1}) = 1$ and $t(\omega x) g(\omega x) - t(x) f(\omega x) = 0$ for all $x \in \Omega$, then $\prod_{a \in \Omega}f(a)/g(a)a = 1$&lt;/p&gt;
&lt;h5 id=&#34;permutation-check&#34;&gt;Permutation Check&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;Setup:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Let $f, g$ be polynomials in $\mathbb{F}_p^{(\le d)}[X]$. The verifier has $comm_f, comm_g$. Prover wants to prove that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$(f(1), f(\omega), f(\omega^2),&amp;hellip;,f(\omega^{k-1})) \in \mathbb{F}_p^k$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;is a permutation of $(g(1), g(\omega), g(\omega^2),&amp;hellip;,g(\omega^{k-1})) \in \mathbb{F}_p^k$.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In another way, the prover wants to prove that $g(\Omega)$ is the same as $f(\Omega)$, just permuted&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To prove this, we will do what is known as the Lipton&amp;rsquo;s trick [Lipton&#39;89]. We will construct two auxiliary polynomials:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$\hat{f} = \prod_{a\in \Omega}(X - f(a))$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$\hat{g} = \prod_{a\in \Omega}(X - f(a))$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Then, $g$ is a permutation of $f$ if and only if $\hat{f}(X) = \hat{g}(X)$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Protocol:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The verifier $V$ will choose random $r \in \mathbb{F} _ p$ and send to prover. To prove that $\hat{f} = \hat{g}$, the prover need to show the evaluation of them at point $r$. Calculating these polynomials are a bit expensive, so we can use prod-check on the rational function: $$\frac{\hat{f}(r)}{\hat{g}(r)} = \prod_{a \in \Omega}\frac{r - f(a)}{r - g(a)} = 1$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If the product is $1$, it means that $\hat{f}(r) = \hat{g}(r)$, and with high probability, $\hat{f} = \hat{r}$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Giapppp/Giapppp.github.io/main/static/images/zkp4_3.png&#34; alt=&#34;Image alt&#34;&gt;&lt;/p&gt;
&lt;p&gt;The cost of this proof is just two commitments, and six evaluations&lt;/p&gt;
&lt;h5 id=&#34;prescribed-permutation-check&#34;&gt;Prescribed permutation check&lt;/h5&gt;
&lt;p&gt;First, let&amp;rsquo;s describe the term &amp;ldquo;permutation&amp;rdquo; here.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$W: \Omega \to \Omega$ is a &lt;strong&gt;permutation of&lt;/strong&gt; $\Omega$ if for all $i \in [k]: W(\omega^i) = \omega^j$ is a bijection. For example, with $k = 3$, we will have $W(\omega^0) = \omega^2, W(\omega^1) = \omega^0, W(\omega^2) = \omega^1$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now, let $f, g$ be polynomials in $\mathbb{F}_p^{(\le d)}[X]$. The verifier has $comm_f, comm_g, comm_W$. The prover wants to prove that $f(y) = g(W(y))$ for all $y \in \Omega$. In another way, $V$ wants to prove that $g(\Omega)$ is the same as $f(\Omega)$, permuted by the prescribed $W$&lt;/p&gt;
&lt;p&gt;Why we can&amp;rsquo;t use a zero-test to prove that $f(y) - g(W(y)) = 0$ on $\Omega$ ? The problem is, the polynomial $f(y) - g(W(y))$ has degree $k^2$, so the prover would need to manipulate polynomials of degree $k^2$. Therefore, we will have quadratic time prover, but our goal is linear time prover.&lt;/p&gt;
&lt;p&gt;We can reduce this to a prod-check on a polynomial of degree $2k$. Firstly, let&amp;rsquo;s talk about the observation that we will use:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Observation:&lt;/strong&gt; if $(W(a), f(a))_{a \in \Omega}$ is a permutation of $(a, g(a))$ for $a \in \Omega$ , then $f(y) = g(W(y))$ for all $y \in \Omega$&lt;/p&gt;
&lt;p&gt;We can prove it by example:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Permutation: $W(\omega^0) = \omega^2, W(\omega^1) = \omega^0, W(\omega^2) = \omega^1$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;First set of pairs: $(\omega^0, g(\omega^0)), (\omega^1, g(\omega^1)), (\omega^2, g(\omega^2))$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Second set of pairs: $(\omega^0, f(\omega^0)), (\omega^2, f(\omega^1)), (\omega^1, f(\omega^2))$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now, we define two auxiliary polynomials, which will be bivariate polynomials of total degree $|\Omega|$:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$\hat{f}(X, Y) = \prod_{a \in \Omega}(X - Y W(a) - f(a))$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$\hat{g}(X, Y) = \prod_{a \in \Omega}(X - Ya - g(a))$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Lemma:&lt;/strong&gt; $\hat{f}(X, Y) = \hat{g}(X, Y) \iff (W(a), f(a)) _ {a \in \Omega}$ is a permutation of $(a, g(a)) _ {a \in \Omega}$&lt;/p&gt;
&lt;p&gt;To proof of this is left as exercise, though if you want to try, you might make use of the fact that $\mathbb{F}_p[X, Y]$ is a unique factorization domain. (I will provide the proof after I learned about UFD :D)&lt;/p&gt;
&lt;p&gt;The protocol continues with two random numbers $r, s$ which are chosen by the verifier. To prove that $\hat{f} = \hat{g}$, the prover need to evaluating $\hat{f}, \hat{g}$ at point $(r, s)$. Now, we can use prod-check like permutation check, instead of evaluating the auxiliary polynomials. Our rational function will be:&lt;/p&gt;
&lt;p&gt;$$\frac{\hat{f}(r, s)}{\hat{g}(r, s)} = \prod_{a \in \Omega} \Big ( \frac{r - s W(a) - f(a)}{r - s a - g(a)} \Big ) = 1$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Therefore, by Schwartz-Zippel lemma, we can conclude that they are equal as bivariate polynomials&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Giapppp/Giapppp.github.io/main/static/images/zkp4_4.png&#34; alt=&#34;Image alt&#34;&gt;&lt;/p&gt;
&lt;p&gt;This protocol is sound and complete, assuming $2d/p$ is negligible. The cost of this protocol is just like the cost described for prod-check.&lt;/p&gt;
&lt;h5 id=&#34;summarize&#34;&gt;Summarize&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Giapppp/Giapppp.github.io/main/static/images/zkp4_5.png&#34; alt=&#34;Image alt&#34;&gt;&lt;/p&gt;
&lt;p&gt;Note that our protocols is public-coin protocol, so we can transform our protocols into non-interactive by Fiat-Shamir method.&lt;/p&gt;
&lt;h3 id=&#34;the-plonk-iop-for-general-circuit&#34;&gt;The PLONK IOP for general circuit&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;PLONK&lt;/strong&gt; is a poly-IOP for a general circuit $C(x, w)$&lt;/p&gt;
&lt;p&gt;PLONK is widely used in practice, some examples are listed in this table&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;Polynomial Commitment Scheme&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;SNARK System&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;KZG&#39;10 (pairing)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Aztec, JellyFish&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Bulletproofs (no pairings)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Halo2 (slow verifier but no trusted setup)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;FRI (hashing)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Plonky2 (no trusted setup)&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;step-1-compile-circuit-to-computation-trace&#34;&gt;Step 1: Compile circuit to computation trace&lt;/h4&gt;
&lt;p&gt;We will use an example circuit with an example evaluation. Our circuit have gates with two inputs and a single input&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Giapppp/Giapppp.github.io/main/static/images/zkp4_6.png&#34; alt=&#34;Image alt&#34;&gt;&lt;/p&gt;
&lt;p&gt;The circuit above computes $(x_1 + x_2)(x_2 + w_1)$. The public inputs are $x_1 = 5, x_2 = 6$ and the secret input (witness) is $w_1 = 1$. We can easily compute the output is $77$, which is also public. The prover will try to prove that he knows a value of $w_1$ that makes the output $77$ with the given public inputs.&lt;/p&gt;
&lt;p&gt;We compile this evaluation into a computation trace, which is simply a table that shows inputs and outputs for each gate, along with circuit inputs.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Circuit inputs are $5, 6, 1$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Gate traces are given in the following table.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Giapppp/Giapppp.github.io/main/static/images/zkp4_7.png&#34; alt=&#34;Image alt&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;step-15-encode-trace-as-a-polynomial&#34;&gt;Step 1.5: Encode trace as a polynomial&lt;/h4&gt;
&lt;p&gt;We will define some notations before start:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$|C|$ is the circuit size, equal to number gates in the circuit&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$|I| = |I_x| + |I_w|$ is the number of inputs to the circuit, which is the number of public inputs and the secret inputs combined&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$d = 3 \times |C| + |I|$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$\Omega = \lbrace 1, \omega, \omega^2, &amp;hellip;, \omega^{d - 1} \rbrace$ where $\omega^d = 1$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Our plan is interpolates $T \in \mathbb{F}_p^{(\le d)}[X]$ such that&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;T encodes all inputs:&lt;/strong&gt; $T(\omega^{-j}) = input_j$ for $j = 1,&amp;hellip;,|I|$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;T encodes all wires:&lt;/strong&gt; For all $l = 0, &amp;hellip;, |C| - 1$, we have&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$T(\omega^{3l})$: left input to gate #l&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$T(\omega^{3l + 1})$: right input to gate #l&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$T(\omega^{3l + 2})$: output of gate #l&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In out example, prover interpolates $T(X)$ such that:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Giapppp/Giapppp.github.io/main/static/images/zkp4_8.png&#34; alt=&#34;Image alt&#34;&gt;&lt;/p&gt;
&lt;p&gt;So, our polynomial will have degree 11, and prover can use FFT to compute the coefficients of $T$ in time $\mathcal{O}(d \log d)$&lt;/p&gt;
&lt;h4 id=&#34;step-2-prove-validity-of-t&#34;&gt;Step 2: Prove validity of $T$&lt;/h4&gt;
&lt;p&gt;After built $T(X) \in \mathbb{F}_p^{(\le d)}[X]$, the prover send $comm_T$ to the verifier. Now, the verifier must make sure that $T$ indeed belongs to the correct computation trace. To do that, it must do the following:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;$T$ encodes the correct inputs&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Every gate is evaluated correctly&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The &amp;ldquo;wiring&amp;rdquo; is implemented correctly&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The output of last gate is 0. Well, in this example the output is $77$, but generally the verifier expects a $0$ output.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;1-t-encodes-the-correct-inputs&#34;&gt;(1): $T$ encodes the correct inputs&lt;/h5&gt;
&lt;p&gt;Both prover and verifier interpolate a polynomial $v(X) \in \mathbb{F}_p^{(\le |I_x|)}[X]$ that encodes the $x$-inputs to the circuit: for $j = 1,&amp;hellip;,|I_x|$, $v(\omega^{-j}) = input_j$&lt;/p&gt;
&lt;p&gt;Next, they will agree on the points encoding the input $\Omega_{inp} = \lbrace \omega^{-1}, \omega^{-2}, &amp;hellip;, \omega^{-|I_x|} \rbrace$. Prover proves (1) by using a ZeroTest on $\Omega_{inp}$ to prove that:&lt;/p&gt;
&lt;p&gt;$$T(y) - v(y) = 0, \forall y \in \Omega_{inp}$$&lt;/p&gt;
&lt;h5 id=&#34;2-every-gate-is-evaluated-correctly&#34;&gt;(2): Every gate is evaluated correctly&lt;/h5&gt;
&lt;p&gt;The idea here is encode gate types using a &lt;u&gt;selector&lt;/u&gt; polynomial $S(X)$&lt;/p&gt;
&lt;p&gt;We define $S(X) \in \mathbb{F}_p^{(\le d)}[X]$ such that $\forall l = 0, &amp;hellip;, |C| - 1$:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$S(\omega^{3l}) = 1$ if gate #l is an addition gate&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$S(\omega^{3l}) = 0$ if gate #l is a multiplication gate&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Then for all $y \in \Omega_{gates} = \lbrace 1, \omega^3, \omega^6, \omega^9,&amp;hellip;, \omega^{3(|C| - 1)}$:&lt;/p&gt;
&lt;p&gt;$$ S(y)[T(y) + T(\omega y)] + (1 - S(y))(T(y) \times T(\omega y)) = T(\omega^2 y)$$&lt;/p&gt;
&lt;p&gt;Here, $T(y), T(\omega y), T(\omega^2 y)$ are the left input, right input and output respectively. Prover will use a zero-test on the set $\Omega_{gates}$ to prove that $\forall y \in \Omega_{gates}$: $$S(y) \times (T(y) + T(\omega y)) + (1 - S(y))(T(y) \times T(\omega y)) - T(\omega^2 y) = 0$$&lt;/p&gt;
&lt;h5 id=&#34;3-the-wiring-is-correct&#34;&gt;(3): The wiring is correct&lt;/h5&gt;
&lt;p&gt;If you look at the circuit (or the table) you will notice that some outputs become inputs on other gates. Prover will have to prove that this wiring has been done correctly&lt;/p&gt;
&lt;p&gt;For that, the wires of $C$ are encoded with respect to their constraints&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Giapppp/Giapppp.github.io/main/static/images/zkp4_9.png&#34; alt=&#34;Image alt&#34;&gt;&lt;/p&gt;
&lt;p&gt;Now, we define a polynomial $W: \Omega \to \Omega$ that implements a rotation: $$W(\omega^{-2}, \omega^1, \omega^3) = (\omega^1, \omega^3, \omega^{-2}), W(\omega^{-1}, \omega^0) = (\omega^0, \omega^{-1})$$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lemma&lt;/strong&gt;: $\forall y \in \Omega: T(y) = T(W(y))$ =&amp;gt; wire constraints are satisfied&lt;/p&gt;
&lt;p&gt;We can prove this lemma by using a prescribed permutation check&lt;/p&gt;
&lt;h5 id=&#34;4-output-of-last-gate-is-0&#34;&gt;(4): Output of last gate is 0&lt;/h5&gt;
&lt;p&gt;Proving the last one is easy, just show that $T(\omega^{3|C| - 1}) = 0$.&lt;/p&gt;
&lt;h4 id=&#34;final-step-the-plonk-poly-iop&#34;&gt;Final step: The PLONK Poly-IOP&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Setup&lt;/strong&gt;: Preprocess the circuit $C$ and outputs $comm_S, comm_W$, which are the selector polynomial $S$ and the wiring polynomial $W$. It is &lt;strong&gt;untrusted&lt;/strong&gt; that everyone can check these commitments were done correctly&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Protocol&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Prover $P$ compiles the circuit to a computation trace, and encodes the entire trace into a polynomial $T(X)$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Verifier $V$ can construct $v(X)$ explicitly from the public inputs $x$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Then $P$ proves validity of $T$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;gates: evaluated correctly by &lt;strong&gt;ZeroTest&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;inputs: correct inputs by &lt;strong&gt;ZeroTest&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;wires: correct wirings by &lt;strong&gt;Prescribed Permutation Check&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;output: correct output by &lt;strong&gt;evaluation proof&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Giapppp/Giapppp.github.io/main/static/images/zkp4_10.png&#34; alt=&#34;Image alt&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Theorem&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The Plonk Poly-IOP is complete and knowledge sound, assuming $7|C|/p$ is negligible&lt;/p&gt;
&lt;h4 id=&#34;extension-of-plonk&#34;&gt;Extension of PLONK&lt;/h4&gt;
&lt;p&gt;The main challenge is to reduce the prover time.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hyperplonk&lt;/strong&gt;: linear prover&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Replace $\Omega$ with $\lbrace 0, 1 \rbrace^t$, where $t = \log_2|\Omega|$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The polynomial $T$ is now a multilinear polynomial in $t$ variables&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ZeroTest is replaced by a multilinear SumCheck (linear time)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Plonkish Arithmetization&lt;/strong&gt;: Custom gates and Plonkup&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;We can use custom gates other than addition gates and multiplication gates. This is used in AIR (Algebraic Intermediate Representation). An example custom gate is: $$\forall y \in \Omega _{gates}: v(y\omega) + v(y)t(y) - t(y\omega) = 0$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Plonkup enables one to ensure that some values in the computation trace are present in a pre-defined list, basically acting like a look-up argument&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Zero Knowledge Proof: Interactive Proofs</title>
      <link>http://localhost:40099/posts/zkp3/</link>
      <pubDate>Thu, 07 Mar 2024 00:00:00 +0000</pubDate>
      <author>michael@michaelneuper.com (Michael Neuper)</author>
      <guid>http://localhost:40099/posts/zkp3/</guid>
      <description>&lt;p&gt;In this post, we will dig deeper about Interactive Proofs, which was described in &lt;a href=&#34;https://giapppp.github.io/posts/zkp1/&#34;&gt;my previous post&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;resources&#34;&gt;Resources&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=4018OYyoAf8&#34;&gt;ZKP MOOC Lecture 4: Interactive Proofs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://theory.cs.princeton.edu/complexity/book.pdf&#34;&gt;Computational Complexity: A Modern Approach, Chapter 8&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://crypto-notes-erhant.vercel.app/zklearning/snarks-via-ips.html#relation-to-interactive-proofs&#34;&gt;Cryptonote-Ehrant&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://people.cs.georgetown.edu/jthaler/ProofsArgsAndZK.pdf&#34;&gt;Chapters 3 and 4 of [Thaler]&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;detail&#34;&gt;Detail&lt;/h2&gt;
&lt;h3 id=&#34;interactive-proofs-motivation--model&#34;&gt;Interactive Proofs: Motivation &amp;amp; Model&lt;/h3&gt;
&lt;p&gt;In an interactive proof, there are two parties: a prover $P$ and a verifier $V$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$P$ solves problem, then tell $V$ the answer&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Then they start a conversation, and the goal of $P$ is convince $V$ the answer is correct&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There are some requirements for interactive proof&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Completeness:&lt;/strong&gt; an honest $P$ can convince $V$ that the answer is correct&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;(Statistical) Soundness:&lt;/strong&gt; $V$ will catch a lying $P$ with high probability. This must hold even if $P$ is computationally unbound and trying to trick $V$ into accept incorrect answer&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If soundness holds only against polynomial-time provers, then the protocol is called an &lt;strong&gt;interactive argument&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;soundness--knowledge-soundness&#34;&gt;Soundness &amp;amp; Knowledge Soundness&lt;/h4&gt;
&lt;p&gt;We will compare &lt;strong&gt;soundness&lt;/strong&gt; and &lt;strong&gt;knowledge soundness&lt;/strong&gt; for circuit-satisfiability&lt;/p&gt;
&lt;p&gt;Let $C$ be some public arithmetic circuit $$C(x, w) \to \mathbb{F}$$ where $x \in \mathbb{F}^n$ is some public statement and $w \in \mathbb{F}^m$ is some secret witness. Let us look at the types of &amp;ldquo;soundness&amp;rdquo; with this example:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Soundness:&lt;/strong&gt; $V$ accepts $\implies \exists w: C(x, w) = 0$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Knowledge Soundness:&lt;/strong&gt; $V$ accepts $\implies P \ {&amp;ldquo;knows&amp;rdquo;} \ w: C(x, w) = 0$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Therefore, we can see that knowledge soundness is stronger, because the verifier must know witness&lt;/p&gt;
&lt;p&gt;But standard soundness is meaningful even in contexts where knowledge soundness isn&amp;rsquo;t, an example is $P$ claims the output of $V$&amp;rsquo;s program on $x$ is 42. Knowledge soundness isn&amp;rsquo;t meaningful at below example because there&amp;rsquo;s no natural witness&lt;/p&gt;
&lt;p&gt;Vice-versa, knowledge soundness is meaningful in contexts where standard soundness isn&amp;rsquo;t. For example, $P$ claims to know the secret key that controls a certain bitcoin wallet. In this one, there does exist a private key to that account for sure, so if using soundness, the verifier can just ignore the verifier and accept, but when using knowledge soundness, $P$ must know the witness&lt;/p&gt;
&lt;p&gt;SNARK&amp;rsquo;s that don&amp;rsquo;t have knowledge soundness are called SNARGs, and they are studied too!&lt;/p&gt;
&lt;h4 id=&#34;public-verifiability&#34;&gt;Public Verifiability&lt;/h4&gt;
&lt;p&gt;Interactive proofs and arguments only convince the party that is choosing/sending the random challenges, and this is bad if there are many verifiers, cuz the prover would have to convince each verifier separately&lt;/p&gt;
&lt;p&gt;To deal with this problem, we can use Fiat-Shamir Transform &lt;a href=&#34;https://link.springer.com/content/pdf/10.1007/3-540-47721-7_12.pdf&#34;&gt;Fiat, Shamir 87&amp;rsquo;&lt;/a&gt; to makes the protocol non-interactive and publicly verifiable&lt;/p&gt;
&lt;p&gt;In summary&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;SNARKs&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;Interactive Proofs&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Non-interactive&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Interactive&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Computationally Secure (?)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Information Theoretically Secure (aka Statistically Secure)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Knowledge Sound&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Not necessary need Knowledge Sound&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;snarks-from-interactive-proofs-outline&#34;&gt;SNARKs from interactive proofs: outline&lt;/h3&gt;
&lt;h4 id=&#34;recall-the-trivial-snark-is-not-a-snark&#34;&gt;Recall: The trivial SNARK is not a SNARK&lt;/h4&gt;
&lt;p&gt;(a) Prover sends $w$ to verifier&lt;/p&gt;
&lt;p&gt;(b) Verifier checks if $C(x, w) = 0$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Problems with this:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(1) $w$ might be long: we want a &amp;ldquo;short&amp;rdquo; proof&lt;/p&gt;
&lt;p&gt;(2) Computing $C(x, w)$ maybe hard: we want a &amp;ldquo;fast&amp;rdquo; verifier&lt;/p&gt;
&lt;h4 id=&#34;snarks-from-interactive-proofs-ips&#34;&gt;SNARKs from Interactive Proofs (IPs)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Slight less trivial: $P$ sends $w$ to $V$, and uses an IP to prove that $w$ satisfies the claimed property&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Fast $V$, but proof is still too long&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;actual-snarks&#34;&gt;Actual SNARKs&lt;/h4&gt;
&lt;p&gt;What actually happens in SNARKs is that, instead of sending $w$ explicitly, the prover will cryptographically commit to $w$ and send that commitment.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$P$ uses an IP to prove that $w$ satisfies the claimed property&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The prover will reveal &lt;strong&gt;just enough&lt;/strong&gt; information about the committed witness $w$ to allow $V$ to run its checks in the IP&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The proof can be made non-interactive using Fiat-Shamir transform&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;review-of-functional-commitments&#34;&gt;Review of functional commitments&lt;/h3&gt;
&lt;p&gt;From previous lecture, we had talked about three important functional commitments&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Polynomial commitments:&lt;/strong&gt; commit to a &lt;u&gt;univariate&lt;/u&gt; $f(X)$ in $\mathbb{F}_p^{(\le d)}[X]$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Multilinear commitments:&lt;/strong&gt; commit to multilinear $f$ in $\mathbb{F}_p^{\le 1}[X_1,&amp;hellip;,X_k]$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Vector commitments (e.g. Merkle Trees):&lt;/strong&gt; commit to $\overrightarrow{c} = (u_1,&amp;hellip;u_d) \in \mathbb{F}_p^d$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now, we will discuss more about each one of them&lt;/p&gt;
&lt;h4 id=&#34;merkle-trees-the-commitment&#34;&gt;Merkle Trees: The commitment&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Giapppp/Giapppp.github.io/main/static/images/zkp3_1.png&#34; alt=&#34;Image alt&#34;&gt;&lt;/p&gt;
&lt;p&gt;In this binary tree, every node is made up of the hash of its children:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;m1 = H(M, Y)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;h2 = H(m3, m4)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;k1 = H(h1, h2)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The root &lt;code&gt;k1&lt;/code&gt; is the &lt;strong&gt;commitment&lt;/strong&gt; to this vector&lt;/p&gt;
&lt;p&gt;When the prover is asked to show that indeed some element of the vector exists at some position, it will provide only the necessary nodes.&lt;/p&gt;
&lt;p&gt;For example, a verifier could ask &amp;ldquo;is there really a &lt;code&gt;t&lt;/code&gt; as position 6?&amp;rdquo;. The prover will give &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt;, &lt;code&gt;h7&lt;/code&gt; and &lt;code&gt;h2&lt;/code&gt; and the verifier will calculate &lt;code&gt;m4&lt;/code&gt;, &lt;code&gt;h1&lt;/code&gt;, &lt;code&gt;k1&lt;/code&gt;. Then, the verifier will compare the calculate &lt;code&gt;h1&lt;/code&gt; to the root given as a commitment by the prover. If they match, then &lt;code&gt;t&lt;/code&gt; is indeed at that specific position in the committed vector&lt;/p&gt;
&lt;p&gt;Summary, we have:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Commitment to vector is root hash&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;To open an entry of the committed vector (leaf of the tree):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Send sibling hashes of all nodes on root-to-leaf path&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$V$ checks these are consistent with the root hash&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;ldquo;Opening proof&amp;rdquo; size is O(log n) hash values&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Binding: one the root hash is sent, the committer is bound to a fixed vector&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Opening any leaf to two different values requires finding a hash collision (assumed to be intractable)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;a-first-polynomial-commitment-commit-to-a-univariate-fx-in-mathbbf_7le-dx&#34;&gt;A First Polynomial commitment: commit to a univariate f(X) in $\mathbb{F}_7^{\le d}[X]$&lt;/h4&gt;
&lt;p&gt;Suppose that we have a polynomial $f(x) \in \mathbb{F}_7^{\le d} [X]$, so this polynomial has values defined onver a very small $n = 7$. The degree should be small too, say something like $d = 3$&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Giapppp/Giapppp.github.io/main/static/images/zkp3_2.png&#34; alt=&#34;Image alt&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$P$ Merkle-commits to all evaluations of the polynomial $f$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;When $V$ requests $f(r)$, $P$ reveals the associated leaf along with opening information&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There exists two problems in this method:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;The number of leaves is $|\mathbb{F}|$, which means the time to compute the commitment is at least $|\mathbb{F}|$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Big problem when working over large fields (say, $|\mathbb{F}| \approx 2^{64}$ or $|\mathbb{F}| \approx 2^{128}$)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$V$ does not know if $f$ has degree at most $d$&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We will see ways to solve these problems within the lecture&lt;/p&gt;
&lt;h3 id=&#34;interactive-proof-design-technical-preliminaries&#34;&gt;Interactive proof design: Technical preliminaries&lt;/h3&gt;
&lt;h4 id=&#34;recap-szdl-lemma&#34;&gt;Recap: SZDL Lemma&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Fact:&lt;/strong&gt; Let $p \ne q$ be univariate polynomials of degree at most $d$. Then $Pr_{r \in \mathbb{F}}[p(r) = q(r)] \le \frac{d}{|\mathbb{F}|}$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The &lt;strong&gt;Schwarts-Zippel-Demillo-Lipton lemma&lt;/strong&gt; is a multivariate generalization:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Let $p \ne q$ be a $l$-variate polynomials of total degree at most $d$. Then $Pr_{r \in \mathbb{F}^l[p(r) = q(r)]} \le \frac{d}{|\mathbb{F}|}$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;ldquo;Total degree&amp;rdquo; refers to the maximum sum of degrees of all variables in any term. E.g., $x_1^2 x_2 + x_1 x_2$ has total degree 3&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;low-degree-and-multilinear-extensions&#34;&gt;Low-Degree and Multilinear Extensions&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Definition &lt;strong&gt;[Extension].&lt;/strong&gt; Given a function $f:{0, 1}^l \to \mathbb{F}$, a $l$-variate polynomial $g$ over $\mathbb{F}$ is said to &lt;strong&gt;extend&lt;/strong&gt; $f$ if $f(x) = g(x)$ for all $x \in {0, 1}^l$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Definition &lt;strong&gt;[Multilinear Extensions].&lt;/strong&gt; Any function $f:{0, 1}^l \in \mathbb{F}$ has a &lt;strong&gt;unique&lt;/strong&gt; multilinear extension (MLE), denoted $\tilde{f}$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Multilinear means the polynomial has degree at most 1 in each variable&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$(1 - x_1)(1 - x_2)$ is multilinear, $x_1^2x_2$ is not&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Giapppp/Giapppp.github.io/main/static/images/zkp3_3.png&#34; alt=&#34;Image alt&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Giapppp/Giapppp.github.io/main/static/images/zkp3_4.png&#34; alt=&#34;Image alt&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Giapppp/Giapppp.github.io/main/static/images/zkp3_5.png&#34; alt=&#34;Image alt&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Giapppp/Giapppp.github.io/main/static/images/zkp3_6.png&#34; alt=&#34;Image alt&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;evaluating-multilinear-extensions-quickly&#34;&gt;Evaluating multilinear extensions quickly&lt;/h4&gt;
&lt;p&gt;Given as input all $2^l$ evaluations of a function $f: {0, 1}^l \to \mathbb{F}$, for any point $r \in \mathbb{F}^l$ there is an $\mathcal{O}(2^l)$-time algorithm for evaluating the MLE $\tilde{f}(r)$&lt;/p&gt;
&lt;p&gt;We will use &lt;strong&gt;Lagrange Interpolation&lt;/strong&gt;. For every input $\omega = (\omega_1, \omega_2,&amp;hellip;,\omega_l) \in {0, 1}^l$, define the multilinear &lt;strong&gt;Lagrange Basis polynomial&lt;/strong&gt; as follow $$\tilde{\delta} _ {\omega}(r) = \prod _ {i=1}^{l}(r_i\omega_i + (1 - r_i)(1 - \omega_i))$$&lt;/p&gt;
&lt;p&gt;So we can get the evaluation of $\tilde{f}(r)$ using these: $$f(r) = \sum _ {\omega \in \lbrace 0, 1 \rbrace^l}f(\omega) \times \tilde{\delta} _ {\omega}(r)$$&lt;/p&gt;
&lt;p&gt;For each $\omega \in {0, 1}^l$, the result $\tilde{\delta} _ {\omega}(r)$ can be computed with $\mathcal{O}(l)$ field operations. As such, the overall algorithm for $2^l$ points takes time $\mathcal{O}(l2^l)$. Using dynamic programming, this can be reduced to $\mathcal{O}(2^l)$&lt;/p&gt;
&lt;h3 id=&#34;the-sum-check-protocol&#34;&gt;The sum-check protocol&lt;/h3&gt;
&lt;p&gt;We are going to work with the sum-check protocol &lt;a href=&#34;https://dl.acm.org/doi/10.1145/146585.146605&#34;&gt;Lund-Fortnow-Karloff-Nissan&#39;90&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The verifier $V$ given oracle access to a $l$-variate polynomial $g$ over field $\mathbb{F}$, and the goal of $V$ is compute the quantity: $$\sum _{b_1 \in \lbrace 0, 1 \rbrace} \sum _ {b_2 \in \lbrace 0, 1 \rbrace} &amp;hellip; \sum _ {b_l \in \lbrace 0, 1 \rbrace} g(b_1, b_2,&amp;hellip;,b_l)$$&lt;/p&gt;
&lt;p&gt;In the naive method, the verifier would query each input, and find the sum in a total of $2^l$ queries. We will consider this to be a costly operation&lt;/p&gt;
&lt;p&gt;Instead, a prover will compute the sum and convince a verifier that this sum is correct. In doing so, the verifier will make only a single query to the oracle! Let&amp;rsquo;s see how. Denote $P$ as prover and $V$ as verifier&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Start:&lt;/strong&gt; $P$ sends the claimed answer $C_1$. The protocol must check that indeed:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$C_1 = \sum _ {b_1 \lbrace 0, 1 \rbrace} \sum _ {b_2 \lbrace 0, 1 \rbrace} &amp;hellip; \sum _ {b_l \lbrace 0, 1 \rbrace} g(b_1, b_2,&amp;hellip;,b_l)$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Round 1:&lt;/strong&gt; $P$ sends &lt;strong&gt;univariate&lt;/strong&gt; polynomial $s_1(X_1)$ claimed to equal $H_1(X_1)$ (H standing for honest):&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$H_1(X_1) =  \sum _ {b_1 \lbrace 0, 1 \rbrace} \sum _ {b_2 \lbrace 0, 1 \rbrace} &amp;hellip; \sum _ {b_l \lbrace 0, 1 \rbrace} g(X_1, b_2,&amp;hellip;,b_l)$$&lt;/p&gt;
&lt;p&gt;&amp;ndash; $V$ need to check two things:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Does $s_1$ equal $H_1$ ?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If $s_1$ does equal $H_1$, is that consistent with the true answer being $C_1$ ?&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&amp;ndash; For the second question, the verifier simply checks that $C_1 = s_1(0) + s_1(1)$. If this check passes, it is safe for $V$ to believe that $C_1$ is the correct answer, so long as $V$ believes that $s_1 = H_1$&lt;/p&gt;
&lt;p&gt;&amp;ndash; For the first question, $V$ just check that $s_1$ and $H_1$ agree at a random point $r_1$&lt;/p&gt;
&lt;p&gt;&amp;ndash; Remember that, $V$ can compute $s_1(r_1)$ directly from $P$&amp;rsquo;s first message, but not $H_1(r_1)$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Round 2:&lt;/strong&gt; They recursively check that $s_1(r_1) = H_1(r_1)$. i.e., that $$s_1(r_1) = = \sum _ {b_2 \lbrace 0, 1 \rbrace} &amp;hellip; \sum _ {b_l \lbrace 0, 1 \rbrace} g(r_1, b_2,&amp;hellip;,b_l)$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Recursion into Rounds 3,4,&amp;hellip;,$l$:&lt;/strong&gt; The verifier and prover keep doing this until the last round&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Final Round (Round $l$):&lt;/strong&gt; $P$ sends univariate polynomial $s_l(X_l)$ claimed to equal $$H_l := g(r_1,&amp;hellip;,r_{l-1}, X_l)$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;ndash; $V$ checks that $s_{l-1}(r_{l-1}) = s_l(0) + s_l(1)$&lt;/p&gt;
&lt;p&gt;&amp;ndash; $V$ picks $r_l$ at random, and needs to check that $s_l(r_l) = g(r_1,&amp;hellip;,r_l)$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The verifier doesn&amp;rsquo;t need for more rounds, because $V$ can perform this check with one oracle query&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;analysis-of-the-sum-check-protocol--costs&#34;&gt;Analysis of the sum-check protocol &amp;amp; costs&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Completeness:&lt;/strong&gt; It holds by design: If $P$ sends the prescribed messages, then all of $V$&amp;rsquo;s checks will pass&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Soundness:&lt;/strong&gt; If $P$ does not send the prescribed messages, then $V$ rejects with probability at least $1 - \frac{ld}{| \mathbb{F} |}$, where $d$ is the maximum degree of $g$ in any variable. You can proof by induction on the number of variables $l$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Total communication is $\mathcal{O}(dl)$ field elements&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$P$ sends $l$ messages, each a univariate polynomial of degree at most $d$. $V$ sends $l - 1$ messages, each consisting of one field element&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$V$&amp;rsquo;s runtime is: $$\mathcal{O}(dl + [time \ required \ to \ evaluate \ g \ at \ one \ point])$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$P$&amp;rsquo;s runtime is at most: $$\mathcal{O}(d * 2^l * [time \ required \ to \ evaluate \ g \ at \ one \ point])$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;application-counting-triangles-in-a-graph&#34;&gt;Application: Counting Triangles in a graph&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; $A \in \lbrace 0, 1 \rbrace^{n \times n}$, representing the adjacency matrix of a graph&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Desired Output:&lt;/strong&gt; $\sum_{(i, j, k) \in [n]^3} A_{ij}A_{jk}A_{ik}$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;The Protocol:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;View $A$ as a function mapping ${0, 1}^{\log n} \times {0, 1}^{\log n}$ to $\mathbb{F}$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Recall that $\tilde{A}$ denotes the multilinear extension of $A$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Define the polynomial $g(X, Y, Z) = \tilde{A}(X, Y) \tilde{A}(Y, Z) \tilde{A}(X, Z)$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Apply the sum-check protocol to $g$ to compute $$\sum_{(a, b, c) \in \lbrace 0, 1 \rbrace ^{3 \log n}} g(a, b, c)$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Costs:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Total communication is $\mathcal{O}(\log n)$, $V$ runtime is $\mathcal{O}(n^2)$, $P$ runtime is $\mathcal{O}(n^3)$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$V$&amp;rsquo;s runtime dominated by evaluating: $$g(r_1, r_2, r_3) = \tilde{A}(r_1, r_2) \tilde{A}(r_2, r_3) \tilde{A}(r_1, r_3)$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;a-snark-for-circuit-satisfiability&#34;&gt;A SNARK for circuit-satisfiability&lt;/h3&gt;
&lt;p&gt;We will use a notion of &lt;strong&gt;transcript&lt;/strong&gt;, which is defined as an assignment of a value to every gate in the circuit. A transcript $T$ is a &lt;strong&gt;correct transcript&lt;/strong&gt; if it assigns the gate values obtained by evaluating the circuit $C$ on a valid witness $\omega$&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Giapppp/Giapppp.github.io/main/static/images/zkp3_7.png&#34; alt=&#34;Image alt&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Giapppp/Giapppp.github.io/main/static/images/zkp3_8.png&#34; alt=&#34;Image alt&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Giapppp/Giapppp.github.io/main/static/images/zkp3_9.png&#34; alt=&#34;Image alt&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;the-polynomial-iop-underlying-the-snark&#34;&gt;The polynomial IOP underlying the SNARK&lt;/h3&gt;
&lt;p&gt;Recall that our SNARK is all about proving that we know a secret witness $\omega$ such that for some public input $x$ and arithmetic circuit $C$ it holds that $C(x, \omega) = 0$. Denote the circuit size as $S = |C|$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;First, we will construct the &lt;strong&gt;correct transcript&lt;/strong&gt; of $C(x, \omega)$, which we denote as $T: {0, 1}^{\log S} \to \mathbb{F}$.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Prover $P$ will calculate the &lt;strong&gt;extension&lt;/strong&gt; of $T$ to obtain a polynomial $h: \mathbb{F}^{\log S} \to \mathbb{F}$. This extension $h$ is the first message sent to the verifier $$\forall x \in \lbrace 0, 1 \rbrace^{\log S}: h(x) = T(x)$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The verifier $V$ needs to verify that this is indeed true, but it will only make a few evaluations of $h$ in doing so&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The intuition behind using extensions is that: If there is even just a singe tiny error in the transcript, so by Schwartz-Zippel theorem,the extension of this transcript will disagree on almost all points with respect to the correct transcript.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 1:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Given $(\log S)$-variate polynomial $h$, identify a related $(3 \log S)$-variate polynomial $g_h$ such that: $h$ extends a correct transcript if and only if $g_h(a, b, c) = 0 \forall (a, b, c) \in {0,1}^{3 \log S}$ and to evaluate $g_h(r)$ at any $r$, suffices to evaluate $h$ at only 3 inputs&lt;/p&gt;
&lt;p&gt;So, we will define $g_h(a, b, c)$ via: $$\tilde{add}(a, b, c)(h(a) - (h(b) + h(c))) + \tilde{mult}(a, b, c) (h(a) - h(b)h(c))$$&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s just quickly introduce what the functions $\tilde{add}$ and $\tilde{mult}$ are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$\tilde{add}(a, b, c)$ is a multilinear extension of a &lt;i&gt;wiring predicate&lt;/i&gt; of a circuit, which return 1 if and only if $a$ is an &lt;strong&gt;addition&lt;/strong&gt; gate and it&amp;rsquo;s two inputs are gates $b$ and $c$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$\tilde{mult}(a, b, c)$ is a multilinear extension of a &lt;i&gt;wiring predicate&lt;/i&gt; of a circuit, which returns 1 if and only if $a$ is a &lt;strong&gt;multiplication&lt;/strong&gt; gate and it&amp;rsquo;s two inputs are gates $b$ and $c$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With the definition, we can see what happens:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$g_h(a, b, c) = h(a) - (h(b) + h(c))$ if $a$ is the label of a gate that computes the &lt;strong&gt;sum&lt;/strong&gt; of gates $b$ and $c$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$g_h(a, b, c) = h(a) - h(b)h(c)$ if $a$ is the label of a gate that computes the product of gates $b$ and $c$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$g_h(a, b, c) = 0$ otherwise&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Step 2:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;How can the verifier check that indeed $\forall (a, b, c) \in {0,1}^{3 \log S}: g_h(a, b, c) = 0$ ? In doing so, verifier should only evaluate $g_h$ at a single point!&lt;/p&gt;
&lt;p&gt;We will use a well-known result in polynomials: $\forall x \in H: g_h(x) = 0 \iff Z_h(x) | Z_H(x)$, where $Z_H(x)$ is called the &lt;strong&gt;vanishing polynomial&lt;/strong&gt; for $H$ and is defined as: $$Z_H(x) = \prod_{a\in H}(x - a)$$&lt;/p&gt;
&lt;p&gt;Then, the polynomial IOP will work as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$P$ sends a polynomial $q$ such that $g_h(X) = q(X) \times Z_H(X)$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$V$ verifies this by picking a random $r \in H$ and checking $g_h(r) = q(r) \times Z_H(r)$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In realworld, this approach is not really the best approach because of it&amp;rsquo;s problems&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$g_h$ is not univariate, it has $3 \log S$ variables&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Having $P$ find and send the quotient polynomial is expensive&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In the final SNARK, this would mean applying polynomial commitment to addition polynomials.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Although it has some problems, but this approach is actually used by well-known schemes: &lt;strong&gt;Marlin&lt;/strong&gt;, &lt;strong&gt;PlonK&lt;/strong&gt; and &lt;strong&gt;Groth16&lt;/strong&gt; do&lt;/p&gt;
&lt;p&gt;To deal with that problems, we can use the sum-check protocol: It handles multivariate polynomials, and doesn&amp;rsquo;t require $P$ to send additional large polynomials&lt;/p&gt;
&lt;p&gt;Here is the general idea (We are working over the integers instead of $\mathbb{F}$):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$V$ checks this by running sum-check protocol with $P$ to compute: $$\sum_{a, b, c \in \lbrace 0, 1 \rbrace^{\log S}}g_h(a, b, c)^2$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If all terms in the sum are 0, the sum is 0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If working over the integers, any non-zero term in the sum will cause the sum to be strictly positive&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;At end of sum-check protocol, $V$ needs to evaluate $g_h(r_1, r_2, r_3)$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Suffices to evaluate $h(r_1), h(r_2), h(r_3)$, because $V$ will only compute $g_h(r_1, r_2, r_3)$ for some random inputs.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Outside of these evaluations, $V$ runs in time $\mathcal{O}(\log S)$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$P$ performs $\mathcal{O}(S)$ field operations given a witness $\omega$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To understand more about the polynomial IOP, I suggest reading Justin Thaler&amp;rsquo;s online book, chapters 3 and 4, which is noticed at the resources section.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Zero Knowledge Proof: SNARK</title>
      <link>http://localhost:40099/posts/zkp2/</link>
      <pubDate>Tue, 20 Feb 2024 00:00:00 +0000</pubDate>
      <author>michael@michaelneuper.com (Michael Neuper)</author>
      <guid>http://localhost:40099/posts/zkp2/</guid>
      <description>&lt;p&gt;In this post, I will try to describe my knowledge about SNARK. By the time I&amp;rsquo;m writing this post, &lt;a href=&#34;https://zkhack.dev/&#34;&gt;ZK Hack Discord&lt;/a&gt; is running ZK Whiteboard Study Group and they are discussing about SNARK, so maybe I&amp;rsquo;m lucky :D&lt;/p&gt;
&lt;h2 id=&#34;resources&#34;&gt;Resources&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=h-94UhJLeck&#34;&gt;ZK Whiteboard Sessions - Module One: What is a SNARK? by Dan Boneh&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.di.ens.fr/~nitulesc/files/Survey-SNARKs.pdf&#34;&gt;zk-SNARKs: A Gentle Introduction by Anca Nitulescu&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;detail&#34;&gt;Detail&lt;/h2&gt;
&lt;h3 id=&#34;what-is-a-snark-&#34;&gt;What is a SNARK ?&lt;/h3&gt;
&lt;p&gt;In the class of non-interactive proofs, a particularly interesting concept for proving integrity of results for large computations is that of &lt;strong&gt;SNARK&lt;/strong&gt;, i.e., &lt;strong&gt;succinct non-interactive argument of knowledge&lt;/strong&gt;. By this term, we denote a proof system which is:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Succinct:&lt;/strong&gt; the size of the proof is very small compared to the size of the statement or the witness, i.e., the size of the computation itself.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Non-interactive:&lt;/strong&gt; it does not require rounds of interaction between the prover and the verifier.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Argument:&lt;/strong&gt; we consider it secure only for provers that have bounded computational resources, which means that provers with enough computational power can convince the verifier of a wrong statement.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Knowledge-sound:&lt;/strong&gt; it is not possible for the prover to construct a proof without knowing a certain so-called witness for the statement; formally, for any prover able to produce a valid proof, there is an extractor capable of extracting a witness (”the knowledge”) for the statement.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Examples:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;I know an $m$ such that $SHA256(m) = 0$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;I know $x$ such that $g^x = h \mod p$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;SNARK&lt;/strong&gt; systems can be further equipped with a zero-knowledge property that enables the proof to be done without revealing anything about the intermediate steps (the witness). We will call these schemes &lt;strong&gt;zk-SNARKs&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;zk-SNARK is really fit with blockchain, so we have lots of applications&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Giapppp/Giapppp.github.io/main/static/images/zkp2_1.png&#34; alt=&#34;Image alt&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;mathematical-background&#34;&gt;Mathematical Background&lt;/h3&gt;
&lt;h4 id=&#34;arithmetic-circuits&#34;&gt;Arithmetic Circuits&lt;/h4&gt;
&lt;p&gt;Let $\mathbb{F}_p$ is a finite field with $p &amp;gt; 2$, then we can define &lt;strong&gt;Arithmetic Circuits&lt;/strong&gt; as:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A directed acyclic graph (DAG) where internal nodes are labeled $+, -$ or $*$, with input $x_i \in \mathbb{F}_p$ and $1$.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;An $n$-variate polynomial with an evaluation recipe&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A map $C: F^n \to F$, with $|C|$ = number of gate&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;argument-systems&#34;&gt;Argument Systems&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Giapppp/Giapppp.github.io/main/static/images/zkp2_2.png&#34; alt=&#34;Image alt&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Giapppp/Giapppp.github.io/main/static/images/zkp2_3.png&#34; alt=&#34;Image alt&#34;&gt;&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;preprocessing argument system&lt;/strong&gt; is made up by three algorithms: Setting Algorithm, Prove Algorithm and Verify Algorithm (S, P, V):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$S(C) \to$ public parameter $(S_p, S_v)$ for prover and verifier&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$P(S_p, x, w) \to$ proof $\pi$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$V(S_v, x, \pi) \to$ accept or reject&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;An argument system requires:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Complete:&lt;/strong&gt; $\forall x, w: C(x, w) = 0 \to Pr[V(s_v, x, P(S_p, x, w)) = accept] = 1$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Soundness:&lt;/strong&gt; If $V$ accepts, then $P$ &amp;ldquo;knows&amp;rdquo; $x$ such that $C(x, w) = 0$, and if $P$ doesn&amp;rsquo;t know $w$, then $Pr[V(s_v, x, P(S_p, x, w)) = accept] = negl$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Zero Knowledge:&lt;/strong&gt;(Optional) $(C, S_p, S_v, x, \pi)$ reveal nothing about $w$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;snark-succinct-non-interactive-argument-of-knowledge&#34;&gt;SNARK: Succinct Non-interactive ARgument of Knowledge&lt;/h4&gt;
&lt;p&gt;A &lt;strong&gt;succinct preprocessing argument system&lt;/strong&gt; is made up by three algorithms: Setting Algorithm, Prove Algorithm and Verify Algorithm (S, P, V):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$S(C) \to$ public parameter $(S_p, S_v)$ for prover and verifier&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$P(S_p, x, w) \to$ &lt;strong&gt;short&lt;/strong&gt; proof $\pi$; $|\pi| = O(log(|C|), \lambda)$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$V(S_v, x, \pi) \to$ accept or reject, &lt;strong&gt;fast to verify&lt;/strong&gt;; $time(V) = O(|x|, log(|C|), \lambda)$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;types-of-preprocessing-setup&#34;&gt;Types of preprocessing setup&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Giapppp/Giapppp.github.io/main/static/images/zkp2_4.png&#34; alt=&#34;Image alt&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Giapppp/Giapppp.github.io/main/static/images/zkp2_5.png&#34; alt=&#34;Image alt&#34;&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Zero Knowledge Proof: An Introduction</title>
      <link>http://localhost:40099/posts/zkp1/</link>
      <pubDate>Sat, 10 Feb 2024 00:00:00 +0000</pubDate>
      <author>michael@michaelneuper.com (Michael Neuper)</author>
      <guid>http://localhost:40099/posts/zkp1/</guid>
      <description>&lt;p&gt;At the first time I have heard about Zero Knowledge Proof, I felt like it&amp;rsquo;s totally different about all cryptography knowledge that i learned, so I decided to learn it! In this post, I will try to explain what Zero Knowledge Proof is, with some examples.&lt;/p&gt;
&lt;p&gt;I will follow the syllabus which was given at &lt;a href=&#34;https://zk-learning.org/&#34;&gt;here&lt;/a&gt;. You will need to read some papers they suggested.&lt;/p&gt;
&lt;h2 id=&#34;resources&#34;&gt;Resources&lt;/h2&gt;
&lt;p&gt;[1] &lt;a href=&#34;https://people.csail.mit.edu/silvio/Selected%20Scientific%20Papers/Proof%20Systems/The_Knowledge_Complexity_Of_Interactive_Proof_Systems.pdf&#34;&gt;[Goldwasser-Micali-Rackoff’89] Knowledge Complexity of Interactive Proof Systems&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2] &lt;a href=&#34;https://www.wisdom.weizmann.ac.il/~oded/PSX/pok.pdf&#34;&gt;[Bellare-Goldreich’92] On Defining Proofs of Knowledge&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[3] &lt;a href=&#34;https://crypto.stanford.edu/cs355/18sp/lec3.pdf&#34;&gt;Lecture 3: Interactive Proofs and Zero-Knowledge&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;detail&#34;&gt;Detail&lt;/h2&gt;
&lt;h3 id=&#34;interactive-proof&#34;&gt;Interactive Proof&lt;/h3&gt;
&lt;p&gt;Informally, the goal of proof is to convince someone that the certain statement is true.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Euler proved that &amp;ldquo;There are infinity primes of the form $4k + 3$&amp;rdquo; by assumming opposite, then lead to contradition&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;To prove that &amp;ldquo;I know a factor $p &amp;lt; N$ of number $N$&amp;rdquo;, you can give anyone $p$ and $N$, and let them calculate $k = N / p$. If $k$ is an integer, then they know that your statement is true&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now, we will talk about another way to describe a proof. We are going to think of proof as an interactive process, with prover and verifier. The prover will prove that the statement is true, and the verifier will check the statement is true or false. This is called &lt;strong&gt;Interactive Proof&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;To define what is Interactive Proof, we need to define some terminology:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Languages:&lt;/strong&gt; A language is simply a set of strings $L \subseteq \lbrace 0, 1 \rbrace^*$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Statement:&lt;/strong&gt; A statement consists a tuple $(x, L)$ or more intuitively, $x \in L$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Interactive Proof System:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;An &lt;em&gt;interactive proof system&lt;/em&gt; for a language $L$ is a protocol between two algorithms: a (possibly unbounded) prover $P$ and an efficient (probabilistic polynomial time) verifier $V$&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Giapppp/Giapppp.github.io/main/static/images/zkp1_1.png&#34; alt=&#34;Image alt&#34;&gt;&lt;/p&gt;
&lt;p&gt;At the start of the protocol, both the prover $P$ and the verifier $V$ are given some instance $x$. At the end of the protocol, the verifier $V$ either accepts (it is convinced that $x \in L$) or rejects (it is not convinced that $x \in L$)&lt;/p&gt;
&lt;p&gt;For a proof system to be useful, it must satisfy the following two properties:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Completeness:&lt;/strong&gt; If $x \in L$, then an honest prover $P$ that just follows protocol specification should be able to convince $V$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Soundness:&lt;/strong&gt; If $x \notin L$, then no prover $P$ (that can possibly cheat by deviating from the protocol specification) should not be able to convince $V$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now we will use definition in [1]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Definition 1.1&lt;/strong&gt;(Interactive Proofs). Let $L$ be any language. Let $\braket{P, V}$ be a protocol specification between a prover $V$ and the verifier $V$. Then we say that $(V, \braket{P, V})$ is an &lt;em&gt;interactive proof system&lt;/em&gt; for $L$ if the following two properties are satisfied:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Completeness:&lt;/strong&gt; $\forall x \in L$,&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
Pr[\braket{P, V}(x) = 1] = 1 - \epsilon
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Soundness:&lt;/strong&gt; $\forall x \notin L$,&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
Pr[\braket{P, V}(x) = 1] = \epsilon
$$&lt;/p&gt;
&lt;p&gt;where $\epsilon$ is negligible&lt;/p&gt;
&lt;h3 id=&#34;zero-knowledge&#34;&gt;Zero-Knowledge&lt;/h3&gt;
&lt;p&gt;Now, we want to prove a statement $x \in L$ without revealing anything else about $x$ other than the fact that $x \in L$. For a language $L$, we have two parties:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;An &lt;em&gt;honest&lt;/em&gt; prover $P$ with input $(x, w)$ such that $w$ is an $L$ witness of $x$. It follows the protocol specification exactly&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;dishonest&lt;/em&gt; verifier $V^*$ with input $x$. It can deviate from the protocol specification.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The goal of the verifier $V^*$ is to infer some information about x from its interaction with $P$&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/Giapppp/Giapppp.github.io/blob/main/static/images/zkp1_2.png?raw=true&#34; alt=&#34;Image alt&#34;&gt;&lt;/p&gt;
&lt;p&gt;In other words, the verifier is given (i) all the transcript $(q_1,a_1,&amp;hellip;q_j,a_j)$ and (ii) the internal coins (randomness) it used $(r_1,&amp;hellip;,r_j)$ throughout the protocol. Then, it tries to learn additional information about $x$. Then, we define the &lt;em&gt;view&lt;/em&gt; of $V^*$ as the random variable&lt;/p&gt;
&lt;p&gt;$$
\mathsf{view}_{V^*}(P, V^*)[x] = \braket{q_1,a_1,r_1,&amp;hellip;,q_j,a_j,r_j}
$$&lt;/p&gt;
&lt;p&gt;Then, our goal is to require that no adversary can gain any additional &amp;ldquo;knowledge&amp;rdquo; about $x$ from $\mathsf{view}_{V^*}(P, V^*)[x]$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Knowledge.&lt;/strong&gt; In cryptography, &amp;ldquo;knowledge&amp;rdquo; defined with respect to things that you can compute efficiently&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Given $N = p * q$ and $p$, we will have &amp;ldquo;knowledge&amp;rdquo; of $q$ by calculate $N / p$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Given $h = \mathsf{SHA256}(m)$, we won&amp;rsquo;t have &amp;ldquo;knowledge&amp;rdquo; of $m$ because we can&amp;rsquo;t calculate $m$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Zero-Knowledge.&lt;/strong&gt; We say that a protocol is zero-knowledge if any information that a verifier could have derived from the transcript of the protocol, &lt;em&gt;could have&lt;/em&gt; orginally been computed efficiently just from $x$ (without any transcript)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Definition 1.2&lt;/strong&gt;(Zero-Knowledge Proof). Let $L \in NP$. Let $\braket{P, V, }$ be a protocol specification between a (possibly unbounded) prover $P$ and a (PPT) verifier $V$. Then, we say that $\braket{P, V}$ is an interactive proof system for $L$ if the following properties are satisfied&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Completeness:&lt;/strong&gt; $\forall x \in L$,&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
Pr[\braket{P, V}(x) = 1] = 1 - \epsilon
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Soundness:&lt;/strong&gt; $\forall x \notin L$,&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
Pr[\braket{P, V}(x) = 1] = \epsilon
$$&lt;/p&gt;
&lt;p&gt;where $\epsilon$ is very small&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;(computational) Zero-Knowledge:&lt;/strong&gt; $\forall V^*$, $\exist (PPT) \ \mathsf{Sim}_{V^*}$ such that $\forall x \in L$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
\mathsf{View}[\braket{P(x, w) \leftrightarrow V^*(x)}] \approx \mathsf{Sim}_{V^*}(x)
$$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.goodaudience.com/understanding-zero-knowledge-proofs-through-simple-examples-df673f796d99&#34;&gt;Understanding Zero-knowledge proofs through illustrated examples&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://codesandbox.io/p/sandbox/github/Byont-Ventures/alibaba-cave-poc/tree/main/?file=%2FREADME.md&#34;&gt;Alibaba Cave Example&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;do-all-np-languages-have-zero-knowledge-interactive-proof-&#34;&gt;Do all NP languages have Zero Knowledge Interactive Proof ?&lt;/h3&gt;
&lt;p&gt;Short answer: Yes&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Theorem 1.1[GMW86, Naor]:&lt;/strong&gt; If one-way functions exist, then every language $L$ in $\mathsf{NP}$ has computational zero knowledge interactive proofs&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Idea of the proofs:&lt;/em&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;[GMW87] Show that an NP-Complete Problem has a ZK Interactive Proof if bit commitments exist&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;[Naor] One Way functions $\to$ bit commitments protocol exist&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Definition 1.3&lt;/strong&gt;(Commitment). An efficiently computable function $\mathsf{Comm}: \mathcal{M} \times \mathcal{R} \to \mathcal{C}$ is a (perfectly) binding commitment if it satisfies the following two properties:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Hiding:&lt;/strong&gt; For all $m_0, m_1 \in \mathcal{M}$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
\lbrace \mathsf{Comm}(m_0, r): r \xleftarrow{\mathcal{R}} \mathcal{R} \rbrace \approx_c \lbrace \mathsf{Comm}(m_1, r): r \xleftarrow{\mathcal{R}} \mathcal{R} \rbrace
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Binding:&lt;/strong&gt; For all $m_0, m_1 \in \mathcal{M}$, $r_0, r_1 \in \mathcal{R}$, if $m_0 \ne m_1$:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
\mathsf{Comm}(m_0, r_0) \ne \mathsf{Comm}(m_1, r_1)
$$&lt;/p&gt;
&lt;p&gt;We can think of a commitment as an envelope that you can&amp;rsquo;t see inside, but binds you to a value&lt;/p&gt;
&lt;p&gt;Example: [3] 3.2&lt;/p&gt;
&lt;h3 id=&#34;application&#34;&gt;Application&lt;/h3&gt;
&lt;p&gt;Can prove relationships between $m_1$ and $m_2$ never revealing either one, only $\mathsf{Comm}(m_1)$ and $\mathsf{Comm}(m_2)$.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Examples:&lt;/em&gt;  $m_1 = m_2, m_1 \ne m_2$ or more generally $v = f(m_1, m_2)$ for any poly-time $f$&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Generally:&lt;/em&gt; A tool to enforce honest behavior in protocols without revealing any information. Idea: protocol players sends along with each &lt;em&gt;next-msg&lt;/em&gt;, a ZK proof that &lt;em&gt;next-msg&lt;/em&gt; = Protocol(history h, randomness r) on history h &amp;amp; c = commit(r)&lt;/p&gt;
&lt;p&gt;Possible since $L = \lbrace \forall r | (next, msg) = Protocol(h, r)$ and $c = \mathsf{Comm}(r) \rbrace$ in NP.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;About Arthur-Merlin protocol:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Arthur-Merlin protocol is an interactive proof system in which the verifier&amp;rsquo;s coin tosses are constrained to be public, mean that prover knows the coin too&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/Giapppp/Giapppp.github.io/blob/main/static/images/zkp1_3.png?raw=true&#34; alt=&#34;image alt&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The question is, is coin privacy necessary ?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Theorem 1.2&lt;/strong&gt;(Goldwasser-Sipper): AM = IP&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In practice, AM protocol can remove the interaction part by using Fiat-Shamir Heuristic&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/Giapppp/Giapppp.github.io/blob/main/static/images/zkp1_4.png?raw=true&#34; alt=&#34;image alt&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt; this does NOT mean every interactive ZK proof can transform to AM protocols and then use Fiat-Shamir heuristic, since IP = AM transformation requires extra super-polynomial powers from Merlin, and for Fiat-Shamir heuristic to work, Prover must be computationally bounded so not to be able to invert H. Yet, many specific protocols, can benefit from this heuristic&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
